[
  {
    "id": "1",
    "zero_shot": "Uma empresa que transporta medicamentos está planejando otimizar o transporte de cargas entre duas cidades. A empresa tem uma frota de caminhões, cada um com uma capacidade máxima de carga diferente.  A lista de capacidades dos caminhões é fornecida em toneladas e está ordenada em ordem crescente. A empresa precisa transportar um volume total de mercadorias, e para otimizar o processo, gostaria de alocar dois caminhões que juntos possam transportar uma quantidade de carga igual à metade do volume total de mercadorias a ser transportado. Desafio: Escreva um programa em Python que receba a lista de capacidades dos caminhões (ordenada em ordem crescente) e o volume total de mercadorias a ser transportado, e retorne as capacidades dos dois caminhões cuja soma seja exatamente a metade do volume total de mercadorias. Se houver múltiplas soluções, qualquer uma pode ser retornada. Se não houver uma solução exata, o programa deve indicar que não é possível alocar dois caminhões que atendam a essa condição. Entrada: Um array ordenado de números inteiros representando as capacidades dos caminhões em toneladas. Um número inteiro representando o volume total de mercadorias a ser transportado. Saída: Um par de números inteiros representando as capacidades dos dois caminhões selecionados. Ou uma mensagem indicando que não é possível atender à condição. Exemplo: Capacidades dos caminhões: [1, 2, 3, 4, 5, 6, 7, 8, 9] Volume total de mercadorias: 20 Resposta esperada: Saída: 5, 5 ou 4, 6 (ou outro par que atenda a condiçãoCaso não haja solução: \"Não é possível alocar dois caminhões com a capacidade exata.\" ",
    "few_shot": "Considere os seguintes exemplos: Uma universidade está planejando alocar seu orçamento anual para financiar dois projetos de pesquisa. A lista de propostas de projetos submetidos inclui os custos estimados para cada projeto, que são dados em milhares de dólares e já estão ordenados em ordem crescente. O reitor da universidade deseja selecionar dois projetos que, juntos, utilizem exatamente metade do orçamento total disponível para o financiamento. Escreva um script em Python que receba a lista de custos estimados dos projetos e o orçamento total disponível, e retorne os custos dos dois projetos cuja soma seja exatamente a metade do orçamento total. def alocar_projetos(custos, orcamento_total): metade_orcamento = orcamento_total // 2 inicio = 0 fim = len(custos) - 1 while inicio < fim: soma = custos[inicio] + custos[fim] if soma == metade_orcamento: return custos[inicio], custos[fim] elif soma < metade_orcamento: inicio += 1 else: fim -= 1 return 'Não é possível alocar dois projetos com os custos exatos.' # Exemplo de uso: custos_projetos = [10, 20, 30, 40, 50, 60, 70, 80, 90] orcamento_total = 100 resultado = alocar_projetos(custos_projetos, orcamento_total) print(resultado) Uma organização filantrópica deseja distribuir seu fundo anual para apoiar dois programas sociais. Cada programa proposto tem um custo estimado, fornecido em milhares de dólares, e os custos estão ordenados em ordem crescente. A organização quer escolher dois programas cujo custo combinado seja exatamente metade do fundo total disponível. Escreva um script em Python que receba a lista de custos estimados dos programas e o fundo total disponível, e retorne os custos dos dois programas que somem exatamente a metade do fundo total. def selecionar_programas(custos, fundo_total):     metade_fundo = fundo_total // 2     inicio = 0     fim = len(custos) - 1          while inicio < fim:         soma = custos[inicio] + custos[fim]         if soma == metade_fundo:             return custos[inicio], custos[fim]         elif soma < metade_fundo:             inicio += 1         else:             fim -= 1          return \"Não é possível selecionar dois programas com os custos exatos.\" # Exemplo de uso custos_programas = [10, 20, 30, 40, 50, 60, 70, 80, 90] fundo_total = 100 resultado = selecionar_programas(custos_programas, fundo_total) print(resultado) Agora resolva o seguinte problema: Uma empresa que transporta medicamentos está planejando otimizar o transporte de cargas entre duas cidades. A empresa tem uma frota de caminhões, cada um com uma capacidade máxima de carga diferente.  A lista de capacidades dos caminhões é fornecida em toneladas e está ordenada em ordem crescente. A empresa precisa transportar um volume total de mercadorias, e para otimizar o processo, gostaria de alocar dois caminhões que juntos possam transportar uma quantidade de carga igual à metade do volume total de mercadorias a ser transportado. Desafio: Escreva um programa que receba a lista de capacidades dos caminhões (ordenada em ordem crescente) e o volume total de mercadorias a ser transportado, e retorne as capacidades dos dois caminhões cuja soma seja exatamente a metade do volume total de mercadorias. Se houver múltiplas soluções, qualquer uma pode ser retornada. Se não houver uma solução exata, o programa deve indicar que não é possível alocar dois caminhões que atendam a essa condição. Entrada: Um array ordenado de números inteiros representando as capacidades dos caminhões em toneladas. Um número inteiro representando o volume total de mercadorias a ser transportado. Saída: Um par de números inteiros representando as capacidades dos dois caminhões selecionados. Ou uma mensagem indicando que não é possível atender à condição. Exemplo: Capacidades dos caminhões: [1, 2, 3, 4, 5, 6, 7, 8, 9] Volume total de mercadorias: 20 Resposta esperada: Saída: 5, 5 ou 4, 6 (ou outro par que atenda a condiçãoCaso não haja solução: 'Não é possível alocar dois caminhões com a capacidade exata.",
    "chain_of_thought": "Exemplo de Pergunta:  Uma universidade está planejando alocar seu orçamento anual para financiar dois projetos de pesquisa. A lista de propostas de projetos submetidos inclui os custos estimados para cada projeto, que são dados em milhares de dólares e já estão ordenados em ordem crescente. O reitor da universidade deseja selecionar dois projetos que, juntos, utilizem exatamente metade do orçamento total disponível para o financiamento. Escreva um script em Python que receba a lista de custos estimados dos projetos e o orçamento total disponível, e retorne os custos dos dois projetos cuja soma seja exatamente a metade do orçamento total.  Raciocínio (Chain of Thought):  Entendimento do Problema:  Temos uma lista ordenada de custos estimados para diferentes projetos. Precisamos encontrar dois projetos cujo custo combinado seja exatamente metade do orçamento total. A lista já está em ordem crescente, o que nos permite procurar por dois valores de forma eficiente. Estratégia:  Iniciar a busca considerando o menor e o maior custo da lista. Calcular a soma desses dois valores. Se a soma for exatamente a metade do orçamento, esses são os projetos desejados. Se a soma for menor que a metade, devemos considerar um custo maior (avançando na lista). Se a soma for maior que a metade, devemos considerar um custo menor (retrocedendo na lista). Continuar esse processo até encontrar a combinação desejada ou até que não seja mais possível encontrar uma combinação. Implementação em Python:   def encontrar_projetos(custos, orcamento_total):     # Calcular a metade do orçamento total     metade_orcamento = orcamento_total / 2          # Inicializar variáveis para a busca     inicio = 0     fim = len(custos) - 1          # Buscar os dois projetos com soma igual à metade do orçamento     while inicio < fim:         soma_atual = custos[inicio] + custos[fim]                  if soma_atual == metade_orcamento:             return (custos[inicio], custos[fim])         elif soma_atual < metade_orcamento:             inicio += 1         else:             fim -= 1          # Se não encontrar nenhum par que atenda ao critério     return None  # Exemplo de uso custos_projetos = [10, 20, 30, 40, 50, 60] orcamento = 200 resultado = encontrar_projetos(custos_projetos, orcamento)  print(resultado) Resolva a pergunta: Uma empresa que transporta medicamentos está planejando otimizar o transporte de cargas entre duas cidades. A empresa tem uma frota de caminhões, cada um com uma capacidade máxima de carga diferente.  A lista de capacidades dos caminhões é fornecida em toneladas e está ordenada em ordem crescente. A empresa precisa transportar um volume total de mercadorias, e para otimizar o processo, gostaria de alocar dois caminhões que juntos possam transportar uma quantidade de carga igual à metade do volume total de mercadorias a ser transportado. Desafio: Escreva um programa que receba a lista de capacidades dos caminhões (ordenada em ordem crescente) e o volume total de mercadorias a ser transportado, e retorne as capacidades dos dois caminhões cuja soma seja exatamente a metade do volume total de mercadorias. Se houver múltiplas soluções, qualquer uma pode ser retornada. Se não houver uma solução exata, o programa deve indicar que não é possível alocar dois caminhões que atendam a essa condição. Entrada: Um array ordenado de números inteiros representando as capacidades dos caminhões em toneladas. Um número inteiro representando o volume total de mercadorias a ser transportado. Saída: Um par de números inteiros representando as capacidades dos dois caminhões selecionados. Ou uma mensagem indicando que não é possível atender à condição. Exemplo: Capacidades dos caminhões: [1, 2, 3, 4, 5, 6, 7, 8, 9] Volume total de mercadorias: 20 Resposta esperada: Saída: 5, 5 ou 4, 6 (ou outro par que atenda a condição) Caso não haja solução: 'Não é possível alocar dois caminhões com a capacidade exata.",
    "dificuldade": "medio",
    "testes": {
      "1": {
        "entrada": [1, 2, 3, 4, 5, 6, 7, 8, 9],
        "volumeTotal": 20,
        "esperado": [1, 9],
        "justificativa": "Testa uma situação onde existem múltiplas soluções válidas e verifica se o programa consegue identificar pelo menos uma delas."
      },
      "2": {
        "entrada": [2, 4, 5, 8, 10],
        "volumeTotal": 30,
        "esperado": [10, 5],
        "justificativa": "Testa uma situação onde a soma exata é possível com valores que não são a primeira ou última posição no array."
      },
      "3": {
        "entrada": [10, 25, 30, 40, 50],
        "volumeTotal": 60,
        "esperado": "Não é possível alocar dois caminhões com a capacidade exata.",
        "justificativa": "Testa um cenário onde nenhum par de capacidades atinge a meta exata, mesmo com números grandes."
      },
      "4": {
        "entrada": [1, 3, 5, 7],
        "volumeTotal": 10,
        "esperado": "Não é possível alocar dois caminhões com a capacidade exata.",
        "justificativa": "Verifica o comportamento do programa quando não há possibilidade de somar exatamente a metade, mesmo com entradas que poderiam parecer próximas à solução."
      },
      "5": {
        "entrada": [],
        "volumeTotal": 20,
        "esperado": "Não é possível alocar dois caminhões com a capacidade exata.",
        "justificativa": "Confirma o comportamento do programa com uma lista vazia, um caso de borda importante."
      }
    },
    "tecnica_ideal": "Two_Pointers",
    "assunto": "two_sum",
    "solucao_otima": {
      "espaco": "O(N)",
      "tempo": "O(n log n)"
    }
  },
  {
    "id": "2",
    "zero_shot": "Matilda, uma estudante de matemática, descobriu uma sala secreta na sua universidade chamada \"Matemateca\". Esta sala contém problemas matemáticos antigos que prometem revelar segredos dos grandes matemáticos a quem conseguir resolvê-los. Um dos desafios encontrados por Matilda envolve calcular o fatorial de um número inteiro não negativo n, uma operação conhecida como \"Produto dos Precursores\". A função fatorial deve receber um número inteiro n e retornar o produto de todos os números inteiros de 1 até n. Este é o seu desafio: ajudar Matilda a implementar esta função para que ela possa desvendar os mistérios matemáticos da Matemateca.  Exemplo 1:  Entrada: n = 5  Saída: 120  Exemplo 2:  Entrada: n = 10  Saída: 3628800. Utilize Python como linguagem de programação.",
    "few_shot": "Considere os seguintes exemplos: Lucas, um jovem curioso, encontrou um livro antigo na biblioteca de sua cidade. O livro continha um enigma: \"Calcule o Produto dos Precursores para o número inteiro n e descubra o segredo dos antigos bibliotecários.\" Lucas descobriu que \"Produto dos Precursores\" se refere ao fatorial de um número. Ele decidiu escrever um programa em Python para resolver o enigma. Entrada: n = 4. Saída Esperada: 24 def fatorial(n):     resultado = 1     for i in range(1, n + 1):         resultado *= i     return resultado  n = 4 print(f \"O fatorial de {n} é {fatorial(n)} \")  Clara estava passeando no parque quando encontrou uma placa misteriosa perto de uma árvore. A placa dizia: \"Resolva o fatorial de n para abrir o portal secreto.\" Clara sabia programar em Python, então ela rapidamente escreveu um código para calcular o fatorial. Entrada: n = 6  Saída Esperada: 720  def fatorial(n):     resultado = 1     for i in range(1, n + 1):         resultado *= i     return resultado  n = 6 print(f\"O fatorial de {n} é {fatorial(n)}\") Agora resolva o seguinte problema: Matilda, uma estudante de matemática, descobriu uma sala secreta na sua universidade chamada \"Matemateca\". Esta sala contém problemas matemáticos antigos que prometem revelar segredos dos grandes matemáticos a quem conseguir resolvê-los. Um dos desafios encontrados por Matilda envolve calcular o fatorial de um número inteiro não negativo n, uma operação conhecida como \"Produto dos Precursores\". A função fatorial deve receber um número inteiro n e retornar o produto de todos os números inteiros de 1 até n. Este é o seu desafio: ajudar Matilda a implementar esta função para que ela possa desvendar os mistérios matemáticos da Matemateca.  Exemplo 1:  Entrada: n = 5  Saída: 120  Exemplo 2:  Entrada: n = 10  Saída: 3628800. Utilize Python como linguagem de programação. ",
    "chain_of_thought": "Marcos, um explorador de enigmas matemáticos, encontrou um antigo Templo das Equações. Na entrada do templo, havia uma inscrição que dizia: \"A chave para desvendar os segredos do templo é o cálculo do fatorial de um número inteiro n. Resolva este problema para avançar.\"  Marcos decidiu utilizar um método de pensamento passo a passo para garantir que ele entendesse cada etapa do processo. Vamos ver como ele resolveu isso.  Entrada: n = 5  Processo de Pensamento:  Primeiro, entenda o que é o fatorial. O fatorial de um número n é o produto de todos os números inteiros de 1 até n. Em termos simples, para calcular o fatorial de 5, você precisa multiplicar 1 * 2 * 3 * 4 * 5. Agora, vamos implementar isso em um código Python. Usaremos um loop para iterar de 1 até n, multiplicando os valores ao longo do caminho. Inicialize uma variável resultado com o valor de 1, pois a multiplicação por 1 não altera o valor. Para cada número i de 1 a n, multiplique resultado por i. No final do loop, resultado conterá o valor do fatorial. Solução em Python: def fatorial(n):     # Inicialize o resultado como 1     resultado = 1     # Itere de 1 até n     for i in range(1, n + 1):         # Multiplique o resultado pelo valor atual de i         resultado *= i     # Retorne o resultado final     return resultado  # Testando com n = 5 n = 5 print(f\"O fatorial de {n} é {fatorial(n)}\")  Matilda, uma estudante de matemática, descobriu uma sala secreta na sua universidade chamada \"Matemateca\". Esta sala contém problemas matemáticos antigos que prometem revelar segredos dos grandes matemáticos a quem conseguir resolvê-los. Um dos desafios encontrados por Matilda envolve calcular o fatorial de um número inteiro não negativo n, uma operação conhecida como \"Produto dos Precursores\". A função fatorial deve receber um número inteiro positivo n e retornar o produto de todos os números inteiros de 1 até n. Este é o seu desafio: ajudar Matilda a implementar esta função para que ela possa desvendar os mistérios matemáticos da Matemateca.  Exemplo 1:  Entrada: n = 5  Saída: 120  Exemplo 2:  Entrada: n = 10  Saída: 3628800. Utilize Python como linguagem de programação.",
    "dificuldade": "facil",
    "testes": {
      "1": {
        "entrada": 0,
        "volumeTotal": 20,
        "esperado": 1,
        "justificativa": "Testa uma situação onde se calcula fatorial de 0."
      },
      "2": {
        "capacidades": 5,
        "volumeTotal": 30,
        "esperado": [10, 5],
        "justificativa": "Testa uma situação onde se calcula um número qualquer."
      }
    },
    "tecnica_ideal": "metodo_iterativo",
    "assunto": "calculo_fatorial",
    "solucao_otima": {
      "espaco": "O(1)",
      "tempo": "O(N)"
    }
  },
  {
    "id": "3",
    "zero_shot": "Em uma vila encantada, havia uma caixa mágica que coletava números toda vez que alguém jogava um dado. Essa caixa guardava os números com muito cuidado, mas tinha um segredo especial: apenas os números que apareciam uma única vez tinham o poder de abrir a fechadura mágica da caixa.  Um dia, um jovem curioso encontrou a caixa e quis abrir o seu segredo. Ele sabia que para conseguir, precisaria somar apenas os números que eram únicos na coleção da caixa.  Objetivo: Dado um array de números inteiros, descubra a soma de todos os números que aparecem exatamente uma vez.  Exemplo:  Input: nums = [1, 2, 3, 2] Output: 4 Explicação: Os números únicos são 1 e 3. A soma desses números é 1 + 3 = 4. Restrições:  1 <= nums.length <= 100 -100 <= nums[i] <= 100  ",
    "few_shot": {
      "tempo": "Considere os seguintes exemplos:  No reino de Treasureland, existiam várias portas que protegiam tesouros preciosos. Cada porta só podia ser aberta com uma chave especial, e essas chaves eram formadas a partir de números mágicos. O segredo era simples: a chave só funcionava se fosse feita da soma de todos os números que apareciam exatamente duas vezes em uma lista especial.  Objetivo:  Dado um array de números inteiros, retorne a soma de todos os números que aparecem exatamente duas vezes.  Exemplo:  Input: nums = [4, 4, 5, 6, 6, 7] Output: 20 Explicação: Os números que aparecem exatamente duas vezes são 4 e 6. A soma é 4 + 4 + 6 + 6 = 20.  def soma_elementos_duas_vezes(nums):     # Contar a frequência de cada número     frequencias = {}     for num in nums:         if num in frequencias:             frequencias[num] += 1         else:             frequencias[num] = 1      # Somar os números que aparecem exatamente duas vezes     soma = 0     for num, count in frequencias.items():         if count == 2:             soma += num * 2          return soma  # Exemplo de uso nums = [4, 4, 5, 6, 6, 7] print(soma_elementos_duas_vezes(nums))  # Output: 20  Em Mystic Valley, os guardiões dos números mágicos decidiram que apenas números que apareciam exatamente três vezes em uma lista especial poderiam ser usados em rituais. Para calcular a força de um ritual, os guardiões somavam todos esses números.  Objetivo:  Dado um array de números inteiros, retorne a soma de todos os números que aparecem exatamente três vezes.  Exemplo:  Input: nums = [2, 2, 2, 3, 3, 4, 5, 5, 5] Output: 21 Explicação: Os números que aparecem exatamente três vezes são 2 e 5. A soma é 2 + 2 + 2 + 5 + 5 + 5 = 21.  def soma_elementos_tres_vezes(nums):     # Contar a frequência de cada número     frequencias = {}     for num in nums:         if num in frequencias:             frequencias[num] += 1         else:             frequencias[num] = 1      # Somar os números que aparecem exatamente três vezes     soma = 0     for num, count in frequencias.items():         if count == 3:             soma += num * 3          return soma  # Exemplo de uso nums = [2, 2, 2, 3, 3, 4, 5, 5, 5] print(soma_elementos_tres_vezes(nums))  # Output: 21  Agora resolva o seguinte problema: Em uma vila encantada, havia uma caixa mágica que coletava números toda vez que alguém jogava um dado. Essa caixa guardava os números com muito cuidado, mas tinha um segredo especial: apenas os números que apareciam uma única vez tinham o poder de abrir a fechadura mágica da caixa.  Um dia, um jovem curioso encontrou a caixa e quis abrir o seu segredo. Ele sabia que para conseguir, precisaria somar apenas os números que eram únicos na coleção da caixa.  Objetivo: Dado um array de números inteiros, descubra a soma de todos os números que aparecem exatamente uma vez.  Exemplo:  Input: nums = [1, 2, 3, 2] Output: 4 Explicação: Os números únicos são 1 e 3. A soma desses números é 1 + 3 = 4. Restrições:  1 <= nums.length <= 100 -100 <= nums[i] <= 100 ",
      "espaco": "Considere os seguintes exemplos: No reino de Treasureland, existiam várias portas que protegiam tesouros preciosos. Cada porta só podia ser aberta com uma chave especial, e essas chaves eram formadas a partir de números mágicos. O segredo era simples: a chave só funcionava se fosse feita da soma de todos os números que apareciam exatamente duas vezes em uma lista especial.  Objetivo:  Dado um array de números inteiros, retorne a soma de todos os números que aparecem exatamente duas vezes.  Exemplo:  Input: nums = [4, 4, 5, 6, 6, 7] Output: 20 Explicação: Os números que aparecem exatamente duas vezes são 4 e 6. A soma é 4 + 4 + 6 + 6 = 20.  def soma_elementos_duas_vezes(nums):     # Array fixo para contar as frequências     freq = [0] * 201      # Contar a frequência de cada número     for num in nums:         freq[num + 100] += 1      # Somar os números que aparecem exatamente duas vezes     soma = 0     for i in range(201):         if freq[i] == 2:             soma += (i - 100) * 2          return soma  # Exemplo de uso nums = [4, 4, 5, 6, 6, 7] print(soma_elementos_duas_vezes(nums))  # Output: 20  Na terra de Numeria, havia uma ponte mágica que só podia ser atravessada se os viajantes soubessem o segredo dos múltiplos. Os guardiões da ponte exigiam que os viajantes encontrassem todos os números que eram múltiplos de exatamente dois outros números na lista e somassem esses números para abrir a ponte.  Objetivo:  Dado um array de números inteiros, retorne a soma de todos os números que são múltiplos de exatamente dois outros números no array.  Exemplo:  Input: nums = [2, 4, 8, 16, 3] Output: 12 Explicação: O número 4 é múltiplo de 2 e 8 é múltiplo de 2 e 4. A soma é 4 + 8 = 12.  def soma_multiplos_de_dois(nums):     soma = 0     for i in range(len(nums)):         count_multiplos = 0         for j in range(len(nums)):             if i != j and nums[i] % nums[j] == 0:                 count_multiplos += 1         if count_multiplos == 2:             soma += nums[i]          return soma  # Exemplo de uso nums = [2, 4, 8, 16, 3] print(soma_multiplos_de_dois(nums))  # Output: 12  Agora resolva o seguinte problema: Em uma vila encantada, havia uma caixa mágica que coletava números toda vez que alguém jogava um dado. Essa caixa guardava os números com muito cuidado, mas tinha um segredo especial: apenas os números que apareciam uma única vez tinham o poder de abrir a fechadura mágica da caixa.  Um dia, um jovem curioso encontrou a caixa e quis abrir o seu segredo. Ele sabia que para conseguir, precisaria somar apenas os números que eram únicos na coleção da caixa.  Objetivo: Dado um array de números inteiros, descubra a soma de todos os números que aparecem exatamente uma vez.  Exemplo:  Input: nums = [1, 2, 3, 2] Output: 4 Explicação: Os números únicos são 1 e 3. A soma desses números é 1 + 3 = 4. Restrições:  1 <= nums.length <= 100 -100 <= nums[i] <= 100 "
    },
    "chain_of_thought": {
      "tempo": "Considere o seguinte exemplo:  Em um reino distante, existia uma sala dos tesouros onde os guardiões só permitiam a entrada de quem conseguisse resolver o enigma dos números únicos. Havia uma lista de números guardada em um pergaminho, e para abrir a porta do tesouro, era necessário somar apenas os números que apareciam exatamente uma vez na lista. Um viajante destemido encontrou o pergaminho e decidiu que queria entrar na sala dos tesouros. Ajude-o a resolver o enigma somando todos os números únicos na lista.  Exemplo:  Input: nums = [4, 5, 6, 4, 7] Output: 18 Explicação: Os números únicos são 5, 6, e 7. A soma desses números é 5 + 6 + 7 = 18. Restrições:  1 <= nums.length <= 100 -100 <= nums[i] <= 100  Para resolver o problema de somar os números que aparecem exatamente uma vez em uma lista, podemos seguir os seguintes passos:  Entender o problema: Precisamos encontrar todos os números que aparecem exatamente uma vez na lista e depois somá-los.  Identificar a frequência dos números: Para cada número na lista, vamos contar quantas vezes ele aparece. Isso pode ser feito usando um dicionário ou um objeto equivalente, onde a chave é o número e o valor é a contagem de vezes que ele aparece na lista.  Selecionar os números únicos: Uma vez que tivermos a contagem de todos os números, podemos identificar quais números aparecem exatamente uma vez. Esses números serão aqueles que têm uma contagem igual a 1.  Calcular a soma: Depois de identificar os números únicos, somamos todos eles para obter o resultado final.  def sum_of_unique(nums):     # Passo 1: Contar a frequência de cada número na lista     frequency = {}     for num in nums:         if num in frequency:             frequency[num] += 1         else:             frequency[num] = 1          # Passo 2: Somar os números que aparecem exatamente uma vez     unique_sum = 0     for num, count in frequency.items():         if count == 1:             unique_sum += num          return unique_sum  # Exemplo de uso nums = [3, 1, 3, 2, 4] result = sum_of_unique(nums) print(\"A soma dos números únicos é:\", result)  Agora resolva o seguinte problema:  Em uma vila encantada, havia uma caixa mágica que coletava números toda vez que alguém jogava um dado. Essa caixa guardava os números com muito cuidado, mas tinha um segredo especial: apenas os números que apareciam uma única vez tinham o poder de abrir a fechadura mágica da caixa.  Um dia, um jovem curioso encontrou a caixa e quis abrir o seu segredo. Ele sabia que para conseguir, precisaria somar apenas os números que eram únicos na coleção da caixa.  Objetivo: Dado um array de números inteiros, descubra a soma de todos os números que aparecem exatamente uma vez.  Exemplo:  Input: nums = [1, 2, 3, 2] Output: 4 Explicação: Os números únicos são 1 e 3. A soma desses números é 1 + 3 = 4. Restrições:  1 <= nums.length <= 100 -100 <= nums[i] <= 100 ",
      "espaco": " Considere o seguinte exemplo:  Em um reino distante, existia uma sala dos tesouros onde os guardiões só permitiam a entrada de quem conseguisse resolver o enigma dos números únicos. Havia uma lista de números guardada em um pergaminho, e para abrir a porta do tesouro, era necessário somar apenas os números que apareciam exatamente uma vez na lista. Um viajante destemido encontrou o pergaminho e decidiu que queria entrar na sala dos tesouros. Ajude-o a resolver o enigma somando todos os números únicos na lista.  Exemplo:  Input: nums = [4, 5, 6, 4, 7] Output: 18 Explicação: Os números únicos são 5, 6, e 7. A soma desses números é 5 + 6 + 7 = 18. Restrições:  1 <= nums.length <= 100 -100 <= nums[i] <= 100 Entender o problema: Precisamos encontrar todos os números que aparecem exatamente uma vez na lista e depois somá-los.  Primeira Passagem - Identificar candidatos a únicos: Vamos realizar uma primeira varredura na lista para identificar todos os números que podem ser únicos. Podemos marcar os números que são candidatos a serem únicos (números que ainda não apareceram mais de uma vez) usando um array auxiliar simples.  Segunda Passagem - Somar os números únicos: Na segunda varredura, verificamos se esses candidatos realmente aparecem apenas uma vez. Se sim, somamos esses números. Isso evita a necessidade de armazenar todos os números e suas contagens ao mesmo tempo, reduzindo o uso de memória  Exemplo com Explicação: Input: nums = [3, 1, 3, 2, 4]  Passo 1: Identificar candidatos a únicos:  3 é candidato a único (primeira ocorrência) 1 é candidato a único (primeira ocorrência) 3 não é mais candidato (segunda ocorrência) 2 é candidato a único (primeira ocorrência) 4 é candidato a único (primeira ocorrência) Passo 2: Verificar candidatos:  3 aparece mais de uma vez, não é único. 1 aparece apenas uma vez, é único. 2 aparece apenas uma vez, é único. 4 aparece apenas uma vez, é único. Passo 3: Somar os números únicos:  Soma = 1 + 2 + 4 = 7  def sum_of_unique_optimized(nums):     unique_sum = 0      for i in range(len(nums)):         # Verifica se nums[i] é único         if nums.count(nums[i]) == 1:             unique_sum += nums[i]      return unique_sum  # Exemplo de uso nums = [3, 1, 3, 2, 4] result = sum_of_unique_optimized(nums) print(\"A soma dos números únicos é:\", result)  Agora resolva o seguinte problema:  Em uma vila encantada, havia uma caixa mágica que coletava números toda vez que alguém jogava um dado. Essa caixa guardava os números com muito cuidado, mas tinha um segredo especial: apenas os números que apareciam uma única vez tinham o poder de abrir a fechadura mágica da caixa.  Um dia, um jovem curioso encontrou a caixa e quis abrir o seu segredo. Ele sabia que para conseguir, precisaria somar apenas os números que eram únicos na coleção da caixa.  Objetivo: Dado um array de números inteiros, descubra a soma de todos os números que aparecem exatamente uma vez.  Exemplo:  Input: nums = [1, 2, 3, 2] Output: 4 Explicação: Os números únicos são 1 e 3. A soma desses números é 1 + 3 = 4. Restrições:  1 <= nums.length <= 100 -100 <= nums[i] <= 100 "
    },
    "dificuldade": "facil",
    "assunto": "manipulacao_vetores",
    "solucao_otima": {
      "espaco": "O(1)",
      "tempo": "O(N)"
    }
  },
  {
    "id": "4",
    "zero_shot": "No antigo Reino dos Números, você foi desafiado a se tornar um Guardião dos Primos. Para provar seu valor, você deve identificar se um número inteiro n é primo. Um número primo é um número maior que 1 que não tem divisores positivos além de 1 e ele mesmo. Implemente a função is_prime(n) que retorna True se n for um número primo, e False caso contrário. Exemplo 1: Entrada: n = 29 Saída: True Explicação: 29 é um número primo porque não é divisível por nenhum número além de 1 e 29. Exemplo 2: Entrada: n = 15 Saída: False Explicação: 15 não é um número primo porque é divisível por 3 e 5. Restrições: n é um número inteiro positivo. Você pode assumir que n é um número inteiro dentro do intervalo [1, 10^7].",
    "few_shot": "No reino dos números, existe uma chave mágica que só pode ser ativada se o número passado para ela for um número primo. Um número primo é aquele que só pode ser dividido por 1 e por ele mesmo, e deve ser maior que 1. Implemente a função is_prime(n) que retorna True se n for um número primo, e False caso contrário. Use uma abordagem eficiente com complexidade O(raiz quadrada de n). Exemplo 1: Entrada: n = 19 Saída: True Explicação: 19 é um número primo porque não é divisível por nenhum número além de 1 e 19. Exemplo 2: Entrada: n = 28 Saída: False Explicação: 28 não é um número primo porque é divisível por 2 e 14. Solução: def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True Outro jovem aventureiro, Miguel, foi encarregado de proteger o grande portão dos números. Para abrir o portão, ele deve determinar se um número é primo. Um número primo é aquele que não tem divisores além de 1 e ele mesmo, e deve ser maior que 1. Exemplo 1: Entrada: n = 31 Saída: True Explicação: 31 é um número primo porque não é divisível por nenhum número além de 1 e 31. Exemplo 2: Entrada: n = 40 Saída: False Explicação: 40 não é um número primo porque é divisível por 2 e 20. Solução: def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True",
    "chain_of_thought": "Você é um matemático que foi contratado para resolver um antigo enigma. O enigma diz respeito à verificação da primalidade de um número inteiro n. Para resolver o enigma, você deve usar uma técnica eficiente que minimiza o número de divisões necessárias. Problema: Implemente a função is_prime(n) que verifica se um número inteiro n é primo. Um número é primo se ele for maior que 1 e não tiver divisores positivos além de 1 e ele mesmo. A solução deve utilizar uma abordagem O(raiz quadrada de n). Exemplo de Raciocínio: 1. Identificação dos Casos Triviais: Verifique se n é menor ou igual a 1. Se for, retorne False porque números menores ou iguais a 1 não são primos. Se n for 2 ou 3, retorne True, pois ambos são primos. 2. Eliminação de Números Pares e Múltiplos de 3: Se n for divisível por 2 ou 3, retorne False, porque n não pode ser primo. 3. Verificação de Divisores até a raiz quadrada de n: Para números maiores, verifique a divisibilidade começando de 5 até a raiz quadrada de n, incrementando de 6 em 6, para cobrir todos os possíveis divisores. Implementação: def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True Exemplo 1: Entrada: n = 37 Saída: True Explicação: 37 é um número primo porque não é divisível por nenhum número além de 1 e 37. Exemplo 2: Entrada: n = 49 Saída: False Explicação: 49 não é um número primo porque é divisível por 7. Restrições: n é um número inteiro positivo. Você pode assumir que n está no intervalo [1, 10^7].",
    "assunto": "calculo_numero_primo",
    "dificuldade": "facil",
    "solucao_otima": {
      "espaco": "O(n)",
      "tempo": "O(sqrt(n))"
    }
  },
  {
    "id": "5",
    "zero_shot": "Maria é uma engenheira de software que recentemente se mudou para a cidade de Metropolis, uma metrópole conhecida por seu complexo sistema de transporte urbano. Para se locomover pela cidade, Maria tem à disposição diversas opções de transporte, como metrô, ônibus, bicicleta compartilhada e serviços de carona. Cada meio de transporte tem suas particularidades: o metrô é rápido, mas as estações nem sempre estão próximas; os ônibus têm rotas mais diretas, mas estão sujeitos ao tráfego; as bicicletas são uma ótima opção em dias de clima favorável, mas nem sempre há estações próximas para devolvê-las; e os serviços de carona oferecem conforto, mas são caros e podem demorar em horas de pico.  Maria precisa planejar sua rota diária de casa para o trabalho considerando múltiplos critérios, como o tempo total de viagem, o custo, o conforto, e o número de trocas de transporte. Ela deseja encontrar a rota mais eficiente que equilibre esses fatores, sabendo que, dependendo da situação, ela pode preferir uma solução que seja rápida, mas cara, ou uma que seja econômica, mas mais lenta. Além disso, Maria está ciente de que as condições de trânsito podem variar durante o dia, afetando os tempos de viagem.  Problema:  Você recebeu um mapa da cidade de Metropolis, representado como um grafo dirigido, onde cada nó representa um ponto de interesse (e.g., estações de metrô, paradas de ônibus, hubs de bicicletas) e cada aresta representa um trajeto entre dois pontos com um meio de transporte específico. Cada aresta tem três valores associados: tempo, custo, e conforto (um valor de 1 a 10, onde 1 é muito desconfortável e 10 é muito confortável).  Sua tarefa é implementar uma função que, dado o grafo e os pontos de origem e destino, determine a rota que otimiza o equilíbrio entre tempo, custo, e conforto, conforme os seguintes critérios:  Minimizar o tempo total de viagem. Minimizar o custo total da viagem. Maximizar o conforto médio da viagem. No entanto, você deve considerar que:  Peso do Tempo: O tempo de viagem pode ter um peso maior ou menor, dependendo da urgência de Maria (um valor de wt entre 1 e 3, onde 3 significa que o tempo é extremamente importante). Peso do Custo: O custo tem um peso wc entre 1 e 3, onde 3 significa que Maria está muito preocupada com o orçamento. Peso do Conforto: O conforto tem um peso wf entre 1 e 3, onde 3 significa que Maria valoriza muito o conforto. Sua função deve retornar a rota ótima que minimiza a função objetivo:  Pontuação=(wt×tempo)+(wc×custo)−(wf×conforto médio)  def optimal_route(graph, start, end, wt, wc, wf):     \"\"\"     :param graph: Um dicionário onde a chave é o ponto de origem e o valor é uma lista de tuplas (destino, tempo, custo, conforto).     :param start: O ponto de origem.     :param end: O ponto de destino.     :param wt: Peso do tempo (1 a 3).     :param wc: Peso do custo (1 a 3).     :param wf: Peso do conforto (1 a 3).     :return: Uma lista de pontos representando a rota ótima do ponto de origem ao ponto de destino, que minimiza a função objetivo.     \"\"\"     pass  Restrições:  O grafo tem no máximo 1000 nós e 10.000 arestas. O tempo e o custo são números inteiros positivos. O conforto é um valor inteiro entre 1 e 10. Exemplo de Entrada:  graph = {     'A': [('B', 10, 5, 7), ('C', 15, 10, 5)],     'B': [('D', 20, 5, 8), ('E', 25, 10, 6)],     'C': [('E', 30, 15, 9)],     'D': [('F', 10, 5, 6)],     'E': [('F', 15, 10, 7)],     'F': [] } start = 'A' end = 'F' wt = 2 wc = 1 wf = 3  [19]",
    "few_shot": {
      "tempo": "Considere o seguinte exemplo:  João é um analista de dados que se mudou para a cidade de Techville, onde ele precisa diariamente calcular a rota mais rápida e econômica para seu trabalho. Techville é conhecida por seu sistema de transporte interligado que inclui trens, ônibus e patinetes elétricos. João tem que decidir entre esses meios de transporte, onde cada opção tem um tempo de viagem, um custo e um nível de conveniência (de 1 a 10, onde 1 é muito inconveniente e 10 é muito conveniente). Dependendo do dia, João pode preferir um trajeto mais barato, ou um trajeto mais rápido e confortável.  Problema:  Você recebeu um grafo direcionado representando as opções de transporte de Techville. Cada nó do grafo representa uma estação ou ponto de interesse, e cada aresta representa uma rota com um meio de transporte específico. Cada aresta tem três valores: tempo, custo e conveniência.  Sua tarefa é implementar uma função que, dado o grafo, determine a rota que otimiza o equilíbrio entre tempo, custo e conveniência, conforme os seguintes critérios:  Minimizar o tempo total de viagem. Minimizar o custo total da viagem. Maximizar a conveniência média da viagem. A função objetivo a ser minimizada é:  Pontuação = (wt * tempo) + (wc * custo) - (wf * conveniência média)  Implemente a função optimal_route(graph, start, end, wt, wc, wf) para resolver este problema.  import heapq  def optimal_route(graph, start, end, wt, wc, wf):     # Fila de prioridade para armazenar (pontuação, nó atual, caminho até o nó atual)     queue = [(0, start, [])]     # Dicionário para armazenar a melhor pontuação encontrada até agora para cada nó     best_scores = {start: 0}          while queue:         current_score, node, path = heapq.heappop(queue)         path = path + [node]                  if node == end:             return path  # Retorna o caminho completo até o destino                  for neighbor, time, cost, convenience in graph.get(node, []):             # Calcula a nova pontuação             new_score = current_score + (wt * time) + (wc * cost) - (wf * convenience)                          if neighbor not in best_scores or new_score < best_scores[neighbor]:                 best_scores[neighbor] = new_score                 heapq.heappush(queue, (new_score, neighbor, path))          return None  # Retorna None se não houver caminho possível  # Exemplo de uso graph = {     'A': [('B', 10, 5, 7), ('C', 15, 10, 5)],     'B': [('D', 20, 5, 8), ('E', 25, 10, 6)],     'C': [('E', 30, 15, 9)],     'D': [('F', 10, 5, 6)],     'E': [('F', 15, 10, 7)],     'F': [] }  start = 'A' end = 'F' wt = 2 wc = 1 wf = 3  print(optimal_route(graph, start, end, wt, wc, wf))  Ana é uma gerente de projetos que se mudou recentemente para a cidade de Innovatown. Para se locomover pela cidade, Ana tem à disposição diversas opções de transporte, como metrô, ônibus, e scooters. Cada meio de transporte tem um tempo de viagem, um custo, e um nível de segurança (de 1 a 10, onde 1 é muito inseguro e 10 é muito seguro). Dependendo do horário e das condições climáticas, Ana pode preferir uma rota que seja mais segura ou que seja mais econômica.  Problema:  Você recebeu um grafo direcionado representando as opções de transporte de Innovatown. Cada nó do grafo representa uma estação ou ponto de interesse, e cada aresta representa uma rota com um meio de transporte específico. Cada aresta tem três valores: tempo, custo e segurança.  Sua tarefa é implementar uma função que, dado o grafo, determine a rota que otimiza o equilíbrio entre tempo, custo e segurança, conforme os seguintes critérios:  Minimizar o tempo total de viagem. Minimizar o custo total da viagem. Maximizar a segurança média da viagem. A função objetivo a ser minimizada é:  Pontuação = (wt * tempo) + (wc * custo) - (wf * segurança média)  Implemente a função optimal_route(graph, start, end, wt, wc, wf) para resolver este problema.  import heapq  def optimal_route(graph, start, end, wt, wc, wf):     # Fila de prioridade para armazenar (pontuação, nó atual, caminho até o nó atual)     queue = [(0, start, [])]     # Dicionário para armazenar a melhor pontuação encontrada até agora para cada nó     best_scores = {start: 0}          while queue:         current_score, node, path = heapq.heappop(queue)         path = path + [node]                  if node == end:             return path  # Retorna o caminho completo até o destino                  for neighbor, time, cost, safety in graph.get(node, []):             # Calcula a nova pontuação             new_score = current_score + (wt * time) + (wc * cost) - (wf * safety)                          if neighbor not in best_scores or new_score < best_scores[neighbor]:                 best_scores[neighbor] = new_score                 heapq.heappush(queue, (new_score, neighbor, path))          return None  # Retorna None se não houver caminho possível  # Exemplo de uso graph = {     'A': [('B', 8, 6, 7), ('C', 20, 10, 6)],     'B': [('D', 15, 7, 8), ('E', 10, 5, 5)],     'C': [('E', 25, 12, 9)],     'D': [('F', 10, 5, 8)],     'E': [('F', 12, 8, 7)],     'F': [] }  start = 'A' end = 'F' wt = 1 wc = 2 wf = 3  print(optimal_route(graph, start, end, wt, wc, wf))  A partir dos exemplos, resolva o seguinte problema:  Maria é uma engenheira de software que recentemente se mudou para a cidade de Metropolis, uma metrópole conhecida por seu complexo sistema de transporte urbano. Para se locomover pela cidade, Maria tem à disposição diversas opções de transporte, como metrô, ônibus, bicicleta compartilhada e serviços de carona. Cada meio de transporte tem suas particularidades: o metrô é rápido, mas as estações nem sempre estão próximas; os ônibus têm rotas mais diretas, mas estão sujeitos ao tráfego; as bicicletas são uma ótima opção em dias de clima favorável, mas nem sempre há estações próximas para devolvê-las; e os serviços de carona oferecem conforto, mas são caros e podem demorar em horas de pico.  Maria precisa planejar sua rota diária de casa para o trabalho considerando múltiplos critérios, como o tempo total de viagem, o custo, o conforto, e o número de trocas de transporte. Ela deseja encontrar a rota mais eficiente que equilibre esses fatores, sabendo que, dependendo da situação, ela pode preferir uma solução que seja rápida, mas cara, ou uma que seja econômica, mas mais lenta. Além disso, Maria está ciente de que as condições de trânsito podem variar durante o dia, afetando os tempos de viagem.  Problema:  Você recebeu um mapa da cidade de Metropolis, representado como um grafo dirigido, onde cada nó representa um ponto de interesse (e.g., estações de metrô, paradas de ônibus, hubs de bicicletas) e cada aresta representa um trajeto entre dois pontos com um meio de transporte específico. Cada aresta tem três valores associados: tempo, custo, e conforto (um valor de 1 a 10, onde 1 é muito desconfortável e 10 é muito confortável).  Sua tarefa é implementar uma função que, dado o grafo e os pontos de origem e destino, determine a rota que otimiza o equilíbrio entre tempo, custo, e conforto, conforme os seguintes critérios:  Minimizar o tempo total de viagem. Minimizar o custo total da viagem. Maximizar o conforto médio da viagem. No entanto, você deve considerar que:  Peso do Tempo: O tempo de viagem pode ter um peso maior ou menor, dependendo da urgência de Maria (um valor de wt entre 1 e 3, onde 3 significa que o tempo é extremamente importante). Peso do Custo: O custo tem um peso wc entre 1 e 3, onde 3 significa que Maria está muito preocupada com o orçamento. Peso do Conforto: O conforto tem um peso wf entre 1 e 3, onde 3 significa que Maria valoriza muito o conforto. Sua função deve retornar a rota ótima que minimiza a função objetivo:  Pontuação=(wt×tempo)+(wc×custo)−(wf×conforto médio)  def optimal_route(graph, start, end, wt, wc, wf):     \"\"\"     :param graph: Um dicionário onde a chave é o ponto de origem e o valor é uma lista de tuplas (destino, tempo, custo, conforto).     :param start: O ponto de origem.     :param end: O ponto de destino.     :param wt: Peso do tempo (1 a 3).     :param wc: Peso do custo (1 a 3).     :param wf: Peso do conforto (1 a 3).     :return: Uma lista de pontos representando a rota ótima do ponto de origem ao ponto de destino, que minimiza a função objetivo.     \"\"\"     pass  Restrições:  O grafo tem no máximo 1000 nós e 10.000 arestas. O tempo e o custo são números inteiros positivos. O conforto é um valor inteiro entre 1 e 10. Exemplo de Entrada:  graph = {     'A': [('B', 10, 5, 7), ('C', 15, 10, 5)],     'B': [('D', 20, 5, 8), ('E', 25, 10, 6)],     'C': [('E', 30, 15, 9)],     'D': [('F', 10, 5, 6)],     'E': [('F', 15, 10, 7)],     'F': [] } start = 'A' end = 'F' wt = 2 wc = 1 wf = 3  [19] ",
      "espaco": "Considere o seguinte exemplo:  João é um analista de dados que se mudou para a cidade de Techville, onde ele precisa diariamente calcular a rota mais rápida e econômica para seu trabalho. Techville é conhecida por seu sistema de transporte interligado que inclui trens, ônibus e patinetes elétricos. João tem que decidir entre esses meios de transporte, onde cada opção tem um tempo de viagem, um custo e um nível de conveniência (de 1 a 10, onde 1 é muito inconveniente e 10 é muito conveniente). Dependendo do dia, João pode preferir um trajeto mais barato, ou um trajeto mais rápido e confortável.  Problema:  Você recebeu um grafo direcionado representando as opções de transporte de Techville. Cada nó do grafo representa uma estação ou ponto de interesse, e cada aresta representa uma rota com um meio de transporte específico. Cada aresta tem três valores: tempo, custo e conveniência.  Sua tarefa é implementar uma função que, dado o grafo, determine a rota que otimiza o equilíbrio entre tempo, custo e conveniência, conforme os seguintes critérios:  Minimizar o tempo total de viagem. Minimizar o custo total da viagem. Maximizar a conveniência média da viagem. A função objetivo a ser minimizada é:  Pontuação = (wt * tempo) + (wc * custo) - (wf * conveniência média)  Implemente a função optimal_route(graph, start, end, wt, wc, wf) para resolver este problema.  def optimal_route(graph, start, end, wt, wc, wf):     # Usando DFS para explorar o grafo e minimizar o uso de memória     def dfs(node, score, path):         if node == end:             return path  # Retorna o caminho quando o destino é alcançado                  best_path = None         best_score = float('inf')                  for neighbor, time, cost, convenience in graph.get(node, []):             new_score = score + (wt * time) + (wc * cost) - (wf * convenience)             result = dfs(neighbor, new_score, path + [neighbor])             if result and new_score < best_score:                 best_path = result                 best_score = new_score                  return best_path          return dfs(start, 0, [start])  # Exemplo de uso graph = {     'A': [('B', 10, 5, 7), ('C', 15, 10, 5)],     'B': [('D', 20, 5, 8), ('E', 25, 10, 6)],     'C': [('E', 30, 15, 9)],     'D': [('F', 10, 5, 6)],     'E': [('F', 15, 10, 7)],     'F': [] }  start = 'A' end = 'F' wt = 2 wc = 1 wf = 3  print(optimal_route(graph, start, end, wt, wc, wf))  Ana é uma gerente de projetos que se mudou recentemente para a cidade de Innovatown. Para se locomover pela cidade, Ana tem à disposição diversas opções de transporte, como metrô, ônibus, e scooters. Cada meio de transporte tem um tempo de viagem, um custo, e um nível de segurança (de 1 a 10, onde 1 é muito inseguro e 10 é muito seguro). Dependendo do horário e das condições climáticas, Ana pode preferir uma rota que seja mais segura ou que seja mais econômica.  Problema:  Você recebeu um grafo direcionado representando as opções de transporte de Innovatown. Cada nó do grafo representa uma estação ou ponto de interesse, e cada aresta representa uma rota com um meio de transporte específico. Cada aresta tem três valores: tempo, custo e segurança.  Sua tarefa é implementar uma função que, dado o grafo, determine a rota que otimiza o equilíbrio entre tempo, custo e segurança, conforme os seguintes critérios:  Minimizar o tempo total de viagem. Minimizar o custo total da viagem. Maximizar a segurança média da viagem. A função objetivo a ser minimizada é:  Pontuação = (wt * tempo) + (wc * custo) - (wf * segurança média)  Implemente a função optimal_route(graph, start, end, wt, wc, wf) para resolver este problema.   def optimal_route(graph, start, end, wt, wc, wf):     # Usando DFS para minimizar o uso de memória     def dfs(node, score, path):         if node == end:             return path  # Retorna o caminho quando o destino é alcançado                  best_path = None         best_score = float('inf')                  for neighbor, time, cost, safety in graph.get(node, []):             new_score = score + (wt * time) + (wc * cost) - (wf * safety)             result = dfs(neighbor, new_score, path + [neighbor])             if result and new_score < best_score:                 best_path = result                 best_score = new_score                  return best_path          return dfs(start, 0, [start])  # Exemplo de uso graph = {     'A': [('B', 8, 6, 7), ('C', 20, 10, 6)],     'B': [('D', 15, 7, 8), ('E', 10, 5, 5)],     'C': [('E', 25, 12, 9)],     'D': [('F', 10, 5, 8)],     'E': [('F', 12, 8, 7)],     'F': [] }  start = 'A' end = 'F' wt = 1 wc = 2 wf = 3  print(optimal_route(graph, start, end, wt, wc, wf))   A partir dos exemplos, resolva o seguinte problema:  Maria é uma engenheira de software que recentemente se mudou para a cidade de Metropolis, uma metrópole conhecida por seu complexo sistema de transporte urbano. Para se locomover pela cidade, Maria tem à disposição diversas opções de transporte, como metrô, ônibus, bicicleta compartilhada e serviços de carona. Cada meio de transporte tem suas particularidades: o metrô é rápido, mas as estações nem sempre estão próximas; os ônibus têm rotas mais diretas, mas estão sujeitos ao tráfego; as bicicletas são uma ótima opção em dias de clima favorável, mas nem sempre há estações próximas para devolvê-las; e os serviços de carona oferecem conforto, mas são caros e podem demorar em horas de pico.  Maria precisa planejar sua rota diária de casa para o trabalho considerando múltiplos critérios, como o tempo total de viagem, o custo, o conforto, e o número de trocas de transporte. Ela deseja encontrar a rota mais eficiente que equilibre esses fatores, sabendo que, dependendo da situação, ela pode preferir uma solução que seja rápida, mas cara, ou uma que seja econômica, mas mais lenta. Além disso, Maria está ciente de que as condições de trânsito podem variar durante o dia, afetando os tempos de viagem.  Problema:  Você recebeu um mapa da cidade de Metropolis, representado como um grafo dirigido, onde cada nó representa um ponto de interesse (e.g., estações de metrô, paradas de ônibus, hubs de bicicletas) e cada aresta representa um trajeto entre dois pontos com um meio de transporte específico. Cada aresta tem três valores associados: tempo, custo, e conforto (um valor de 1 a 10, onde 1 é muito desconfortável e 10 é muito confortável).  Sua tarefa é implementar uma função que, dado o grafo e os pontos de origem e destino, determine a rota que otimiza o equilíbrio entre tempo, custo, e conforto, conforme os seguintes critérios:  Minimizar o tempo total de viagem. Minimizar o custo total da viagem. Maximizar o conforto médio da viagem. No entanto, você deve considerar que:  Peso do Tempo: O tempo de viagem pode ter um peso maior ou menor, dependendo da urgência de Maria (um valor de wt entre 1 e 3, onde 3 significa que o tempo é extremamente importante). Peso do Custo: O custo tem um peso wc entre 1 e 3, onde 3 significa que Maria está muito preocupada com o orçamento. Peso do Conforto: O conforto tem um peso wf entre 1 e 3, onde 3 significa que Maria valoriza muito o conforto. Sua função deve retornar a rota ótima que minimiza a função objetivo:  Pontuação=(wt×tempo)+(wc×custo)−(wf×conforto médio)  def optimal_route(graph, start, end, wt, wc, wf):     \"\"\"     :param graph: Um dicionário onde a chave é o ponto de origem e o valor é uma lista de tuplas (destino, tempo, custo, conforto).     :param start: O ponto de origem.     :param end: O ponto de destino.     :param wt: Peso do tempo (1 a 3).     :param wc: Peso do custo (1 a 3).     :param wf: Peso do conforto (1 a 3).     :return: Uma lista de pontos representando a rota ótima do ponto de origem ao ponto de destino, que minimiza a função objetivo.     \"\"\"     pass  Restrições:  O grafo tem no máximo 1000 nós e 10.000 arestas. O tempo e o custo são números inteiros positivos. O conforto é um valor inteiro entre 1 e 10. Exemplo de Entrada:  graph = {     'A': [('B', 10, 5, 7), ('C', 15, 10, 5)],     'B': [('D', 20, 5, 8), ('E', 25, 10, 6)],     'C': [('E', 30, 15, 9)],     'D': [('F', 10, 5, 6)],     'E': [('F', 15, 10, 7)],     'F': [] } start = 'A' end = 'F' wt = 2 wc = 1 wf = 3  [19]"
    },
    "chain_of_thought": {
      "tempo": " Considere o seguinte exemplo: João é um analista de logística que trabalha para uma grande empresa de distribuição em Cosmópolis, uma cidade onde o trânsito pode ser imprevisível e caótico. Ele foi encarregado de otimizar as rotas de entrega da empresa para garantir que os produtos sejam entregues da maneira mais eficiente possível. Cosmópolis possui um vasto sistema de rotas que inclui avenidas principais, ruas secundárias, e atalhos por bairros residenciais, cada um com seus próprios tempos de viagem, custos operacionais, e níveis de conforto para os motoristas.  João deve encontrar a melhor rota possível para as entregas diárias, levando em conta o tempo de viagem, o custo da rota, e o conforto dos motoristas, mas com uma ênfase maior no tempo de viagem. Dependendo da prioridade da empresa, João pode ajustar o peso dado ao tempo (wt), ao custo (wc), e ao conforto (wf) da viagem. Seu objetivo é implementar uma função que, dado o grafo da cidade e os pesos de cada fator, determine a rota ótima que minimiza o tempo total de viagem enquanto considera os outros fatores.  Você recebeu um mapa da cidade de Cosmópolis, representado como um grafo dirigido. Cada nó representa um ponto de entrega, e cada aresta tem três valores associados: tempo, custo, e conforto (um valor de 1 a 10, onde 1 é muito desconfortável e 10 é muito confortável).  Sua tarefa é implementar uma função que, dado o grafo, os pontos de origem e destino, e os pesos de tempo, custo e conforto, determine a rota que minimiza a função objetivo:  Pontuação = (wt * tempo) + (wc * custo) - (wf * conforto médio)  Linha de Raciocínio para Otimização de Tempo (Complexidade Assintótica): Identificação do Objetivo: Queremos minimizar a função objetivo dada a prioridade dos pesos wt, wc e wf. No entanto, o foco principal é garantir que a solução seja otimizada em termos de tempo de execução (complexidade assintótica).  Simplificação e Foco em Tempo: Para otimizar o tempo de execução, consideraremos um algoritmo que permite calcular o caminho mínimo de forma eficiente. Neste caso, o algoritmo de Dijkstra, otimizado com uma fila de prioridade (heap), é uma escolha adequada, pois nos permite encontrar a solução mais rápida.  Modificamos o algoritmo de Dijkstra para incluir os pesos wt, wc e wf na função objetivo, mas mantendo o foco em minimizar a complexidade do tempo de execução. A função de avaliação a ser minimizada será:  Score = (wt * cumulative_time) + (wc * cumulative_cost) - (wf * cumulative_confort)  import heapq  def optimal_route(graph, start, end, wt, wc, wf):     # Fila de prioridade para armazenar (score acumulado, tempo, custo, conforto, nó atual)     queue = [(0, 0, 0, 0, start)]     # Dicionários para armazenar o menor score, tempo, custo e conforto encontrados até o nó     best_scores = {start: 0}          while queue:         current_score, cumulative_time, cumulative_cost, cumulative_comfort, current_node = heapq.heappop(queue)                  if current_node == end:             return current_score  # Retorna o score da rota ótima                  for neighbor, time, cost, comfort in graph.get(current_node, []):             new_time = cumulative_time + time             new_cost = cumulative_cost + cost             new_comfort = cumulative_comfort + comfort             new_score = (wt * new_time) + (wc * new_cost) - (wf * new_comfort)                          if new_score < best_scores.get(neighbor, float('inf')):                 best_scores[neighbor] = new_score                 heapq.heappush(queue, (new_score, new_time, new_cost, new_comfort, neighbor))          return float('inf')  # Caso não haja rota possível    Agora resolva o seguinte problema:   Maria é uma engenheira de software que recentemente se mudou para a cidade de Metropolis, uma metrópole conhecida por seu complexo sistema de transporte urbano. Para se locomover pela cidade, Maria tem à disposição diversas opções de transporte, como metrô, ônibus, bicicleta compartilhada e serviços de carona. Cada meio de transporte tem suas particularidades: o metrô é rápido, mas as estações nem sempre estão próximas; os ônibus têm rotas mais diretas, mas estão sujeitos ao tráfego; as bicicletas são uma ótima opção em dias de clima favorável, mas nem sempre há estações próximas para devolvê-las; e os serviços de carona oferecem conforto, mas são caros e podem demorar em horas de pico.  Maria precisa planejar sua rota diária de casa para o trabalho considerando múltiplos critérios, como o tempo total de viagem, o custo, o conforto, e o número de trocas de transporte. Ela deseja encontrar a rota mais eficiente que equilibre esses fatores, sabendo que, dependendo da situação, ela pode preferir uma solução que seja rápida, mas cara, ou uma que seja econômica, mas mais lenta. Além disso, Maria está ciente de que as condições de trânsito podem variar durante o dia, afetando os tempos de viagem.  Problema:  Você recebeu um mapa da cidade de Metropolis, representado como um grafo dirigido, onde cada nó representa um ponto de interesse (e.g., estações de metrô, paradas de ônibus, hubs de bicicletas) e cada aresta representa um trajeto entre dois pontos com um meio de transporte específico. Cada aresta tem três valores associados: tempo, custo, e conforto (um valor de 1 a 10, onde 1 é muito desconfortável e 10 é muito confortável).  Sua tarefa é implementar uma função que, dado o grafo e os pontos de origem e destino, determine a rota que otimiza o equilíbrio entre tempo, custo, e conforto, conforme os seguintes critérios:  Minimizar o tempo total de viagem. Minimizar o custo total da viagem. Maximizar o conforto médio da viagem. No entanto, você deve considerar que:  Peso do Tempo: O tempo de viagem pode ter um peso maior ou menor, dependendo da urgência de Maria (um valor de wt entre 1 e 3, onde 3 significa que o tempo é extremamente importante). Peso do Custo: O custo tem um peso wc entre 1 e 3, onde 3 significa que Maria está muito preocupada com o orçamento. Peso do Conforto: O conforto tem um peso wf entre 1 e 3, onde 3 significa que Maria valoriza muito o conforto. Sua função deve retornar a rota ótima que minimiza a função objetivo:  Pontuação=(wt×tempo)+(wc×custo)−(wf×conforto médio)  def optimal_route(graph, start, end, wt, wc, wf):     \"\"\"     :param graph: Um dicionário onde a chave é o ponto de origem e o valor é uma lista de tuplas (destino, tempo, custo, conforto).     :param start: O ponto de origem.     :param end: O ponto de destino.     :param wt: Peso do tempo (1 a 3).     :param wc: Peso do custo (1 a 3).     :param wf: Peso do conforto (1 a 3).     :return: Uma lista de pontos representando a rota ótima do ponto de origem ao ponto de destino, que minimiza a função objetivo.     \"\"\"     pass  Restrições:  O grafo tem no máximo 1000 nós e 10.000 arestas. O tempo e o custo são números inteiros positivos. O conforto é um valor inteiro entre 1 e 10. Exemplo de Entrada:  graph = {     'A': [('B', 10, 5, 7), ('C', 15, 10, 5)],     'B': [('D', 20, 5, 8), ('E', 25, 10, 6)],     'C': [('E', 30, 15, 9)],     'D': [('F', 10, 5, 6)],     'E': [('F', 15, 10, 7)],     'F': [] } start = 'A' end = 'F' wt = 2 wc = 1 wf = 3  [19] ",
      "espaco": " Ana é uma cientista de dados que trabalha em uma empresa de logística em Techville, uma cidade que recentemente implementou um sistema de entrega autônoma altamente sofisticado. Ela foi encarregada de encontrar as rotas mais eficientes para os drones de entrega, levando em conta múltiplos fatores como tempo de viagem, custo de operação e a segurança das rotas. No entanto, devido à quantidade limitada de memória nos drones, Ana precisa desenvolver uma solução que minimize o uso de recursos computacionais enquanto calcula a melhor rota.  Problema: Você recebeu um mapa da cidade de Techville, representado como um grafo dirigido, onde cada nó representa um ponto de entrega e cada aresta representa um caminho entre dois pontos, com valores associados de tempo, custo e segurança (conforto). A tarefa de Ana é implementar uma função que, dado o grafo e os pesos de tempo (wt), custo (wc) e segurança (wf), determine a rota ótima para os drones de entrega, priorizando o uso eficiente de memória.  Linha de Raciocínio para Otimização de Espaço: Identificação do Objetivo: O objetivo principal é encontrar a rota que melhor equilibre o tempo, o custo e a segurança, mas com a necessidade crucial de minimizar o uso de memória durante o processo de cálculo.  Simplificação do Problema: Ao invés de utilizar abordagens que armazenam grandes quantidades de dados na memória, optaremos por uma abordagem que explora o grafo de maneira recursiva e em profundidade, mantendo apenas o essencial em memória.  Estratégia de Resolução: Utilizaremos uma busca em profundidade (DFS), que explora cada caminho possível de maneira recursiva até atingir o destino ou até que todos os caminhos tenham sido considerados. Ao longo do caminho, manteremos apenas o mínimo necessário para reconstruir a solução final, o que reduz o uso de memória.  Exploração Recursiva: Durante a DFS, a cada nó visitado, calcularemos a pontuação baseada nos pesos dados para tempo, custo e segurança. Se encontrarmos uma rota melhor, ela será armazenada, descartando qualquer outra rota que ocupe mais memória.  Reconstrução do Caminho: Uma vez que a DFS explore todos os caminhos, o caminho ótimo será reconstruído a partir dos dados mínimos armazenados durante a busca, garantindo que a solução final seja eficiente em termos de espaço.  def space_efficient_dfs(graph, start, end, wt, wc, wf):     best_path = []     best_score = float('inf')          def dfs(node, path, score):         nonlocal best_path, best_score                  if node == end:             if score < best_score:                 best_score = score                 best_path = list(path)             return                  for neighbor, time, cost, comfort in graph.get(node, []):             new_score = score + wt * time + wc * cost - wf * comfort             if new_score < best_score:                 path.append(neighbor)                 dfs(neighbor, path, new_score)                 path.pop()          dfs(start, [start], 0)     return best_path if best_path else None      "
    },
    "solucao_otima": {
      "espaco": "O(V + E); E=arestas, V=vertices",
      "tempo": "O(E log V); E=arestas, V=vertices"
    },
    "dificuldade": "dificil",
    "tecnica_ideal": "variacao_dijkstra",
    "assunto": "otimizacao_rotas_grafos"
  },
  {
    "id": "6",
    "dificuldade": "medio",
    "assunto": "ordenacao",
    "zero_shot": "No renomado Congresso Anual de Computação, realizado na grandiosa cidade de Algoritmolândia, os maiores programadores e cientistas da computação do mundo se reuniram para compartilhar suas últimas descobertas e participar de desafios que colocavam suas habilidades à prova.  Este ano, um dos eventos mais esperados era a Maratona de Ordenação. Os participantes recebiam listas de códigos secretos que precisavam ser organizados de acordo com uma ordem especial. Os códigos eram compostos por sequências de strings, e a ordem de classificação dessas strings era definida por um alfabeto personalizado, criado pelos organizadores do congresso. Somente aqueles que conseguissem ordenar as listas de forma correta e eficiente poderiam conquistar o prêmio: a prestigiosa Medalha de Algoritmos Perfeitos.  Entre os competidores estava a jovem e talentosa programadora Ada, que tinha um grande sonho de se tornar a campeã do congresso. Mas para isso, ela precisava resolver o desafio com maestria. E você, como mentor de Ada, deve ajudá-la a vencer essa maratona!  Problema Descrição: Você deve ajudar Ada a implementar uma função que ordene uma lista de strings de acordo com uma ordem de caracteres personalizada fornecida pelos organizadores do congresso. A string que define essa ordem contém todos os caracteres únicos em uma sequência específica, e a lista de strings deve ser ordenada conforme essa ordem.  Se duas strings começarem com o mesmo caractere, a comparação deve continuar com o próximo caractere, e assim por diante. Se uma string for um prefixo de outra, a string mais curta deve vir primeiro na ordem final.  Exemplo: # Ordem personalizada fornecida pelos organizadores do congresso order = \"zyxwvutsrqponmlkjihgfedcba\"  # Lista de strings que Ada precisa ordenar strings = [\"apple\", \"app\", \"ace\", \"banana\", \"bat\", \"cat\"]  # Função esperada para ordenação def custom_sort_congress(order: str, strings: List[str]) -> List[str]:     # Sua implementação vai aqui     pass  # Exemplo de execução custom_sort_congress(order, strings)  Entrada:  order: Uma string de comprimento 26 representando a ordem personalizada dos caracteres. strings: Uma lista de strings que precisam ser ordenadas.  Saída:  Retorne a lista de strings ordenadas de acordo com a ordem personalizada.  Exemplo 1:  order = \"zyxwvutsrqponmlkjihgfedcba\" strings = [\"apple\", \"app\", \"ace\", \"banana\", \"bat\", \"cat\"]  custom_sort_congress(order, strings)  Saída Esperada:  [\"cat\", \"bat\", \"banana\", \"apple\", \"app\", \"ace\"]  ",
    "few_shot": {
      "tempo": "Considere os seguintes exemplos: No Reino de Velocitânia, há uma tradição onde os mensageiros mais rápidos competem em uma corrida anual. Cada mensageiro carrega uma série de mensagens secretas que precisam ser entregues na ordem correta, baseada em um código secreto fornecido pelos sábios do reino. A ordem dos caracteres no código determina a prioridade das mensagens durante a entrega.  Você, como estrategista real, deve ajudar a ordenar as mensagens dos mensageiros para que possam entregá-las na ordem correta e garantir a vitória na corrida.  Exemplo: order = \"qwertyuiopasdfghjklzxcvbnm\" messages = [\"secret\", \"quest\", \"quiver\", \"queue\"]  custom_sort_messages(order, messages) Saída Esperada: [\"quest\", \"queue\", \"quiver\", \"secret\"]  Solução:  def custom_sort_messages(order: str, messages: List[str]) -> List[str]:     order_map = {char: i for i, char in enumerate(order)}          def convert_string_to_indices(s):         return tuple(order_map[char] for char in s)          return sorted(messages, key=convert_string_to_indices)  Em uma expedição arqueológica, um grupo de cientistas encontrou uma série de documentos antigos, todos escritos em um idioma desconhecido. Cada documento tem um título único, e os arqueólogos descobriram um pergaminho com a ordem exata dos caracteres usados por essa civilização antiga. Para catalogar os documentos corretamente, os arqueólogos precisam organizá-los de acordo com a ordem dos caracteres descrita no pergaminho.  Você, como o principal analista da equipe, foi encarregado de ordenar os documentos para preservá-los na sequência correta.  Exemplo:  order = \"mnbvcxzlkjhgfdsapoiuytrewq\" documents = [\"manuscript\", \"scroll\", \"tablet\", \"inscription\"]  custom_sort_documents(order, documents)  Saída Esperada:  [\"tablet\", \"scroll\", \"manuscript\", \"inscription\"]  def custom_sort_documents(order: str, documents: List[str]) -> List[str]:     order_map = {char: i for i, char in enumerate(order)}          def convert_string_to_indices(s):         return tuple(order_map[char] for char in s)          return sorted(documents, key=convert_string_to_indices)  Agora resolva o seguinte problema: No renomado Congresso Anual de Computação, realizado na grandiosa cidade de Algoritmolândia, os maiores programadores e cientistas da computação do mundo se reuniram para compartilhar suas últimas descobertas e participar de desafios que colocavam suas habilidades à prova.  Este ano, um dos eventos mais esperados era a Maratona de Ordenação. Os participantes recebiam listas de códigos secretos que precisavam ser organizados de acordo com uma ordem especial. Os códigos eram compostos por sequências de strings, e a ordem de classificação dessas strings era definida por um alfabeto personalizado, criado pelos organizadores do congresso. Somente aqueles que conseguissem ordenar as listas de forma correta e eficiente poderiam conquistar o prêmio: a prestigiosa Medalha de Algoritmos Perfeitos.  Entre os competidores estava a jovem e talentosa programadora Ada, que tinha um grande sonho de se tornar a campeã do congresso. Mas para isso, ela precisava resolver o desafio com maestria. E você, como mentor de Ada, deve ajudá-la a vencer essa maratona!  Problema Descrição: Você deve ajudar Ada a implementar uma função que ordene uma lista de strings de acordo com uma ordem de caracteres personalizada fornecida pelos organizadores do congresso. A string que define essa ordem contém todos os caracteres únicos em uma sequência específica, e a lista de strings deve ser ordenada conforme essa ordem.  Se duas strings começarem com o mesmo caractere, a comparação deve continuar com o próximo caractere, e assim por diante. Se uma string for um prefixo de outra, a string mais curta deve vir primeiro na ordem final.  Exemplo: # Ordem personalizada fornecida pelos organizadores do congresso order = \"zyxwvutsrqponmlkjihgfedcba\"  # Lista de strings que Ada precisa ordenar strings = [\"apple\", \"app\", \"ace\", \"banana\", \"bat\", \"cat\"]  # Função esperada para ordenação def custom_sort_congress(order: str, strings: List[str]) -> List[str]:     # Sua implementação vai aqui     pass  # Exemplo de execução custom_sort_congress(order, strings)  Entrada:  order: Uma string de comprimento 26 representando a ordem personalizada dos caracteres. strings: Uma lista de strings que precisam ser ordenadas.  Saída:  Retorne a lista de strings ordenadas de acordo com a ordem personalizada.  Exemplo 1:  order = \"zyxwvutsrqponmlkjihgfedcba\" strings = [\"apple\", \"app\", \"ace\", \"banana\", \"bat\", \"cat\"]  custom_sort_congress(order, strings)  Saída Esperada:  [\"cat\", \"bat\", \"banana\", \"apple\", \"app\", \"ace\"]",
      "espaco": " Considere os seguintes exemplos: No ano de 2250, uma equipe de exploradores espaciais da Terra partiu em uma expedição para catalogar novas espécies de plantas em planetas distantes. Durante a missão, eles descobriram várias plantas exóticas, cada uma com um nome único. No entanto, a linguagem utilizada pelos nativos do planeta faz uso de um alfabeto muito diferente do alfabeto terrestre.  Para documentar corretamente as plantas em seus registros, os exploradores precisam ordenar os nomes das plantas de acordo com o alfabeto local que lhes foi ensinado pelos nativos. Como parte da equipe de apoio na Terra, sua tarefa é ajudar os exploradores a organizar essa lista.  Exemplo:  order = \"xknvczmywbadrpluqefgiojhst\" plants = [\"bloomflower\", \"arktree\", \"neptuleaf\", \"sunvine\"]  custom_sort_plants(order, plants)  Saída Esperada: [\"neptuleaf\", \"arktree\", \"bloomflower\", \"sunvine\"]  Solução:  def custom_sort_plants(order: str, plants: List[str]) -> List[str]:     order_map = {char: i for i, char in enumerate(order)}          def compare_strings(s1, s2):         for c1, c2 in zip(s1, s2):             if order_map[c1] != order_map[c2]:                 return order_map[c1] < order_map[c2]         return len(s1) < len(s2)          n = len(plants)     for i in range(n):         min_index = i         for j in range(i + 1, n):             if compare_strings(plants[j], plants[min_index]):                 min_index = j         plants[i], plants[min_index] = plants[min_index], plants[i]          return plants  Na antiga Biblioteca de Alexandria, os arquivistas eram conhecidos por sua habilidade em organizar vastos volumes de pergaminhos. Um dia, um misterioso viajante trouxe consigo uma coleção de textos de uma civilização perdida, escritos em uma linguagem desconhecida.  Cada pergaminho tinha um título único, mas a ordem alfabética desses títulos seguia um padrão completamente diferente dos conhecidos pelos arquivistas. O viajante, antes de partir, deixou com eles uma pedra com os caracteres e a ordem correta para organizar os pergaminhos.  Agora, os arquivistas precisam de sua ajuda para reorganizar os pergaminhos de acordo com essa nova ordem. Sua missão é garantir que os textos sejam organizados corretamente para que possam ser estudados.  Exemplo: order = \"mnbvcxzlkjhgfdsapoiuytrewq\" scrolls = [\"manuscript\", \"epistle\", \"codex\", \"folio\"]  custom_sort_scrolls(order, scrolls) Saída Esperada: [\"folio\", \"codex\", \"epistle\", \"manuscript\"] Solução: def custom_sort_scrolls(order: str, scrolls: List[str]) -> List[str]:     order_map = {char: i for i, char in enumerate(order)}          def compare_strings(s1, s2):         for c1, c2 in zip(s1, s2):             if order_map[c1] != order_map[c2]:                 return order_map[c1] < order_map[c2]         return len(s1) < len(s2)          n = len(scrolls)     for i in range(n):         min_index = i         for j in range(i + 1, n):             if compare_strings(scrolls[j], scrolls[min_index]):                 min_index = j         scrolls[i], scrolls[min_index] = scrolls[min_index], scrolls[i]          return scrolls  Agora resolva o seguinte problema  Considere os seguintes exemplos: No renomado Congresso Anual de Computação, realizado na grandiosa cidade de Algoritmolândia, os maiores programadores e cientistas da computação do mundo se reuniram para compartilhar suas últimas descobertas e participar de desafios que colocavam suas habilidades à prova.  Este ano, um dos eventos mais esperados era a Maratona de Ordenação. Os participantes recebiam listas de códigos secretos que precisavam ser organizados de acordo com uma ordem especial. Os códigos eram compostos por sequências de strings, e a ordem de classificação dessas strings era definida por um alfabeto personalizado, criado pelos organizadores do congresso. Somente aqueles que conseguissem ordenar as listas de forma correta e eficiente poderiam conquistar o prêmio: a prestigiosa Medalha de Algoritmos Perfeitos.  Entre os competidores estava a jovem e talentosa programadora Ada, que tinha um grande sonho de se tornar a campeã do congresso. Mas para isso, ela precisava resolver o desafio com maestria. E você, como mentor de Ada, deve ajudá-la a vencer essa maratona!  Problema Descrição: Você deve ajudar Ada a implementar uma função que ordene uma lista de strings de acordo com uma ordem de caracteres personalizada fornecida pelos organizadores do congresso. A string que define essa ordem contém todos os caracteres únicos em uma sequência específica, e a lista de strings deve ser ordenada conforme essa ordem.  Se duas strings começarem com o mesmo caractere, a comparação deve continuar com o próximo caractere, e assim por diante. Se uma string for um prefixo de outra, a string mais curta deve vir primeiro na ordem final.  Exemplo: # Ordem personalizada fornecida pelos organizadores do congresso order = \"zyxwvutsrqponmlkjihgfedcba\"  # Lista de strings que Ada precisa ordenar strings = [\"apple\", \"app\", \"ace\", \"banana\", \"bat\", \"cat\"]  # Função esperada para ordenação def custom_sort_congress(order: str, strings: List[str]) -> List[str]:     # Sua implementação vai aqui     pass  # Exemplo de execução custom_sort_congress(order, strings)  Entrada:  order: Uma string de comprimento 26 representando a ordem personalizada dos caracteres. strings: Uma lista de strings que precisam ser ordenadas.  Saída:  Retorne a lista de strings ordenadas de acordo com a ordem personalizada.  Exemplo 1:  order = \"zyxwvutsrqponmlkjihgfedcba\" strings = [\"apple\", \"app\", \"ace\", \"banana\", \"bat\", \"cat\"]  custom_sort_congress(order, strings)  Saída Esperada:  [\"cat\", \"bat\", \"banana\", \"apple\", \"app\", \"ace\"]   "
    },
    "chain_of_thought": {
      "tempo": " Considere o seguinte exemplo: No reino mágico de Cristallia, os magos competem anualmente no Desafio dos Cristais Místicos. Cada mago recebe uma coleção de cristais, e a tarefa é organizá-los em uma ordem específica, determinada pela disposição dos astros no céu. Cada cristal tem um nome, e a ordem dos caracteres no céu noturno é única e muda a cada ano.  Este ano, você foi escolhido para ajudar o mago mais jovem, Orion, a vencer o desafio. Sua missão é organizar os nomes dos cristais de acordo com a ordem celestial o mais rápido possível.  Exemplo:  order = \"lfckjvhsrxtpdmqzwaibngeyou\" crystals = [\"amethyst\", \"ruby\", \"opal\", \"diamond\"]  custom_sort_crystals(order, crystals)  Saída Esperada:  [\"ruby\", \"opal\", \"amethyst\", \"diamond\"]   Passo 1: Mapeamento dos Caracteres Primeiro, criaremos um mapeamento dos caracteres da ordem celestial para seus respectivos índices. Esse mapeamento nos permitirá transformar cada cristal em uma tupla de inteiros, onde cada inteiro representa a posição do caractere na ordem personalizada. Isso facilita comparações rápidas.  Passo 2: Conversão de Strings Para garantir que a ordenação seja o mais rápida possível, converteremos cada nome de cristal em uma tupla de inteiros usando o mapeamento criado. Comparar tuplas de inteiros é muito mais eficiente do que comparar strings caractere por caractere.  Passo 3: Ordenação Rápida Usaremos o algoritmo de ordenação mais eficiente disponível (sorted() em Python, que utiliza Timsort), aproveitando as tuplas de inteiros como chave de ordenação. O Timsort é rápido e possui uma complexidade de tempo de O(n log n).  def custom_sort_crystals(order: str, crystals: List[str]) -> List[str]:     # Passo 1: Criar um mapa que associa cada caractere ao seu índice na ordem     order_map = {char: i for i, char in enumerate(order)}          # Passo 2: Converter cada nome de cristal em uma tupla de índices     def convert_string_to_indices(s):         return tuple(order_map[char] for char in s)          # Passo 3: Ordenar os cristais usando as tuplas de índices como chave     return sorted(crystals, key=convert_string_to_indices)  Agora resolva o seguinte problema:  No renomado Congresso Anual de Computação, realizado na grandiosa cidade de Algoritmolândia, os maiores programadores e cientistas da computação do mundo se reuniram para compartilhar suas últimas descobertas e participar de desafios que colocavam suas habilidades à prova.  Este ano, um dos eventos mais esperados era a Maratona de Ordenação. Os participantes recebiam listas de códigos secretos que precisavam ser organizados de acordo com uma ordem especial. Os códigos eram compostos por sequências de strings, e a ordem de classificação dessas strings era definida por um alfabeto personalizado, criado pelos organizadores do congresso. Somente aqueles que conseguissem ordenar as listas de forma correta e eficiente poderiam conquistar o prêmio: a prestigiosa Medalha de Algoritmos Perfeitos.  Entre os competidores estava a jovem e talentosa programadora Ada, que tinha um grande sonho de se tornar a campeã do congresso. Mas para isso, ela precisava resolver o desafio com maestria. E você, como mentor de Ada, deve ajudá-la a vencer essa maratona!  Problema Descrição: Você deve ajudar Ada a implementar uma função que ordene uma lista de strings de acordo com uma ordem de caracteres personalizada fornecida pelos organizadores do congresso. A string que define essa ordem contém todos os caracteres únicos em uma sequência específica, e a lista de strings deve ser ordenada conforme essa ordem.  Se duas strings começarem com o mesmo caractere, a comparação deve continuar com o próximo caractere, e assim por diante. Se uma string for um prefixo de outra, a string mais curta deve vir primeiro na ordem final.  Exemplo: # Ordem personalizada fornecida pelos organizadores do congresso order = \"zyxwvutsrqponmlkjihgfedcba\"  # Lista de strings que Ada precisa ordenar strings = [\"apple\", \"app\", \"ace\", \"banana\", \"bat\", \"cat\"]  # Função esperada para ordenação def custom_sort_congress(order: str, strings: List[str]) -> List[str]:     # Sua implementação vai aqui     pass  # Exemplo de execução custom_sort_congress(order, strings)  Entrada:  order: Uma string de comprimento 26 representando a ordem personalizada dos caracteres. strings: Uma lista de strings que precisam ser ordenadas.  Saída:  Retorne a lista de strings ordenadas de acordo com a ordem personalizada.  Exemplo 1:  order = \"zyxwvutsrqponmlkjihgfedcba\" strings = [\"apple\", \"app\", \"ace\", \"banana\", \"bat\", \"cat\"]  custom_sort_congress(order, strings)  Saída Esperada:  [\"cat\", \"bat\", \"banana\", \"apple\", \"app\", \"ace\"]  ",
      "espaco": "Considere o seguinte exemplo: Em um reino distante, o Grande Torneio de Anagramas é realizado uma vez por ano. Os competidores devem demonstrar sua habilidade em descobrir e ordenar palavras mágicas, onde a ordem dos caracteres não segue o alfabeto comum, mas sim uma ordem mágica definida pelos sábios do reino.  Este ano, o desafio é especialmente difícil: os competidores precisam ordenar uma lista de palavras mágicas usando essa ordem secreta de caracteres. Apenas aqueles que puderem resolver o desafio sem o uso de magia adicional (ou seja, sem consumir mais espaço do que o necessário) poderão vencer.  Você é um dos competidores e precisa criar um plano para vencer o torneio. Use sua inteligência para encontrar uma maneira de ordenar as palavras de acordo com a ordem mágica, utilizando o mínimo de recursos possíveis.  Exemplo:  order = \"qazwsxedcrfvtgbyhnujmikolp\" words = [\"wizard\", \"warrior\", \"witch\", \"wolf\"]  custom_sort_words(order, words)  Saída Esperada: [\"warrior\", \"wolf\", \"witch\", \"wizard\"]  Passo 1: Mapeamento dos Caracteres Primeiro, precisamos mapear a ordem mágica dos caracteres em um dicionário. Esse dicionário vai nos ajudar a comparar os caracteres das palavras de forma eficiente. Como o número de caracteres é limitado (apenas 26 letras do alfabeto), o espaço usado por esse dicionário é constante, ou seja, O(1).  Passo 2: Comparação de Palavras Para ordenar as palavras, precisamos de uma maneira de compará-las de acordo com a ordem mágica. A ideia é comparar os caracteres das palavras uma a uma, usando o mapeamento que criamos. Se dois caracteres diferirem, podemos decidir imediatamente qual palavra deve vir antes na lista ordenada. Se os caracteres forem iguais, passamos para o próximo par de caracteres.  Se uma palavra for um prefixo de outra (por exemplo, \"warrior\" e \"warriors\"), a palavra mais curta deve vir primeiro.  Passo 3: Ordenação In-Place Vamos usar um algoritmo de ordenação que funcione in-place, como o Selection Sort, para garantir que não estamos usando espaço adicional além do necessário para o mapeamento e a comparação. Embora esse algoritmo seja menos eficiente em termos de tempo (O(n^2)), ele é eficiente em termos de espaço (O(1)), que é o nosso principal objetivo.  Implementação da Solução  def custom_sort_words(order: str, words: List[str]) -> List[str]:     # Passo 1: Cria um mapa de ordem com espaço fixo O(1)     order_map = {char: i for i, char in enumerate(order)}          def compare_words(w1, w2):         # Passo 2: Compara duas palavras caractere por caractere         for c1, c2 in zip(w1, w2):             if order_map[c1] != order_map[c2]:                 return order_map[c1] < order_map[c2]         # Se uma palavra é prefixo da outra, a palavra mais curta vem primeiro         return len(w1) < len(w2)          # Passo 3: Implementação de Selection Sort in-place     n = len(words)     for i in range(n):         min_index = i         for j in range(i + 1, n):             if compare_words(words[j], words[min_index]):                 min_index = j         # Troca in-place         words[i], words[min_index] = words[min_index], words[i]          return words  Agora resolva o seguinte problema:  No renomado Congresso Anual de Computação, realizado na grandiosa cidade de Algoritmolândia, os maiores programadores e cientistas da computação do mundo se reuniram para compartilhar suas últimas descobertas e participar de desafios que colocavam suas habilidades à prova.  Este ano, um dos eventos mais esperados era a Maratona de Ordenação. Os participantes recebiam listas de códigos secretos que precisavam ser organizados de acordo com uma ordem especial. Os códigos eram compostos por sequências de strings, e a ordem de classificação dessas strings era definida por um alfabeto personalizado, criado pelos organizadores do congresso. Somente aqueles que conseguissem ordenar as listas de forma correta e eficiente poderiam conquistar o prêmio: a prestigiosa Medalha de Algoritmos Perfeitos.  Entre os competidores estava a jovem e talentosa programadora Ada, que tinha um grande sonho de se tornar a campeã do congresso. Mas para isso, ela precisava resolver o desafio com maestria. E você, como mentor de Ada, deve ajudá-la a vencer essa maratona!  Problema Descrição: Você deve ajudar Ada a implementar uma função que ordene uma lista de strings de acordo com uma ordem de caracteres personalizada fornecida pelos organizadores do congresso. A string que define essa ordem contém todos os caracteres únicos em uma sequência específica, e a lista de strings deve ser ordenada conforme essa ordem.  Se duas strings começarem com o mesmo caractere, a comparação deve continuar com o próximo caractere, e assim por diante. Se uma string for um prefixo de outra, a string mais curta deve vir primeiro na ordem final.  Exemplo: # Ordem personalizada fornecida pelos organizadores do congresso order = \"zyxwvutsrqponmlkjihgfedcba\"  # Lista de strings que Ada precisa ordenar strings = [\"apple\", \"app\", \"ace\", \"banana\", \"bat\", \"cat\"]  # Função esperada para ordenação def custom_sort_congress(order: str, strings: List[str]) -> List[str]:     # Sua implementação vai aqui     pass  # Exemplo de execução custom_sort_congress(order, strings)  Entrada:  order: Uma string de comprimento 26 representando a ordem personalizada dos caracteres. strings: Uma lista de strings que precisam ser ordenadas.  Saída:  Retorne a lista de strings ordenadas de acordo com a ordem personalizada.  Exemplo 1:  order = \"zyxwvutsrqponmlkjihgfedcba\" strings = [\"apple\", \"app\", \"ace\", \"banana\", \"bat\", \"cat\"]  custom_sort_congress(order, strings)  Saída Esperada:  [\"cat\", \"bat\", \"banana\", \"apple\", \"app\", \"ace\"]"
    },
    "solucao_otima": {
      "espaco": "O(1)",
      "tempo": "O(N * L)"
    }
  },
  {
    "id": "7",
    "dificuldade": "dificil",
    "assunto": "autocomplete_palavra",
    "tecnica_ideal": "trie",
    "zero_shot": "Na antiga cidade de Eldoria, existe uma biblioteca mágica repleta de livros encantados. Esses livros contêm todo o conhecimento do mundo, e os bibliotecários de Eldoria têm a tarefa sagrada de organizar e proteger esses livros. Um dos rituais mais importantes realizados na biblioteca é a contagem dos livros que compartilham um prefixo comum no título, algo que só pode ser feito por aqueles que conhecem os segredos dos Tries.  Você, um jovem aprendiz de bibliotecário, recebeu a tarefa de contar quantos livros na biblioteca começam com um determinado prefixo. A Grande Bibliotecária lhe entregou uma lista dos títulos dos livros e pediu para você implementar uma solução que conte quantos deles começam com o prefixo mágico.  Tarefa Implemente uma função count_books_with_prefix que, dada uma lista de títulos de livros e um prefixo, retorne o número de livros que começam com esse prefixo.  Função  def count_books_with_prefix(books: List[str], prefix: str) -> int:     # Implementação  Parâmetros books: Uma lista de strings books, onde cada string representa o título de um livro. O número de títulos N está no intervalo [1, 1000]. O comprimento de cada título está no intervalo [1, 100]. prefix: Uma string prefix que representa o prefixo mágico. O comprimento do prefixo está no intervalo [1, 100].  Retorno Retorne um inteiro representando o número de livros na lista que começam com o prefixo dado.  Exemplo Exemplo 1: books = [\"magic spells\", \"magical creatures\", \"magnificent potions\", \"alchemy\", \"magnetism\"] prefix = \"mag\"  output = count_books_with_prefix(books, prefix)  Saída Esperada:  3  # \"magic spells\", \"magical creatures\", \"magnificent potions\" começam com \"mag\"",
    "few_shot": {
      "espaco": " Considere o seguinte exemplo:  Na vila de Arithmoria, há um desafio tradicional realizado a cada ano para encontrar a sequência numérica mais longa que começa com um determinado prefixo. Você, um matemático curioso, foi convidado para resolver este desafio. Recebeu uma lista de sequências numéricas e uma sequência prefixo, e sua tarefa é determinar quantas dessas sequências começam com o prefixo fornecido.  **Tarefa:**  Implemente uma função `count_sequences_with_prefix` que, dada uma lista de sequências numéricas e um prefixo, retorne o número de sequências que começam com esse prefixo.  **Função:**  def count_sequences_with_prefix(sequences: List[str], prefix: str) -> int:     # Implementação  **Parâmetros**  - `sequences`: Uma lista de strings `sequences`, onde cada string representa uma sequência numérica. O número de sequências N está no intervalo [1, 1000]. O comprimento de cada sequência está no intervalo [1, 100]. - `prefix`: Uma string `prefix` que representa o prefixo numérico. O comprimento do prefixo está no intervalo [1, 100].  **Retorno**  Retorne um inteiro que representa o número de sequências na lista que começam com o prefixo fornecido.  **Exemplo**   sequences = [\"123456\", \"123789\", \"789123\", \"456123\", \"123\"] prefix = \"123\"  output = count_sequences_with_prefix(sequences, prefix)   **Saída Esperada:**   3  # \"123456\", \"123789\", \"123\" começam com \"123\"   #### Resposta:   def count_sequences_with_prefix(sequences: List[str], prefix: str) -> int:     count = 0     prefix_len = len(prefix)     for seq in sequences:         if seq[:prefix_len] == prefix:             count += 1     return count   ### Prompt 2  Na cidade mística de Numbria, existe um jogo de cartas onde cada carta possui um conjunto de símbolos representado por sequências de caracteres. Durante o jogo, os jogadores precisam identificar todas as cartas que possuem um determinado prefixo em seus símbolos. Você, um entusiasta de jogos de cartas, foi contratado para resolver esta tarefa. Recebeu uma lista de cartas e um prefixo específico, e sua missão é contar quantas cartas possuem o prefixo nos seus símbolos.  **Tarefa:**  Implemente uma função `count_cards_with_prefix` que, dada uma lista de símbolos de cartas e um prefixo, retorne o número de cartas que possuem o prefixo fornecido.  **Função:**   def count_cards_with_prefix(cards: List[str], prefix: str) -> int:     # Implementação   **Parâmetros**  - `cards`: Uma lista de strings `cards`, onde cada string representa os símbolos de uma carta. O número de cartas N está no intervalo [1, 1000]. O comprimento de cada sequência de símbolos está no intervalo [1, 100]. - `prefix`: Uma string `prefix` que representa o prefixo dos símbolos. O comprimento do prefixo está no intervalo [1, 100].  **Retorno**  Retorne um inteiro que representa o número de cartas na lista que possuem o prefixo fornecido.  **Exemplo**   cards = [\"abc123\", \"abcd456\", \"ab123\", \"bc123\", \"abcd\"] prefix = \"abc\"  output = count_cards_with_prefix(cards, prefix)   **Saída Esperada:**   3  # \"abc123\", \"abcd456\", \"abcd\" começam com \"abc\"   #### Resposta:   def count_cards_with_prefix(cards: List[str], prefix: str) -> int:     count = 0     prefix_len = len(prefix)     for card in cards:         if card[:prefix_len] == prefix:             count += 1     return count  Agora resolva o seguinte problema:  Na antiga cidade de Eldoria, existe uma biblioteca mágica repleta de livros encantados. Esses livros contêm todo o conhecimento do mundo, e os bibliotecários de Eldoria têm a tarefa sagrada de organizar e proteger esses livros. Um dos rituais mais importantes realizados na biblioteca é a contagem dos livros que compartilham um prefixo comum no título, algo que só pode ser feito por aqueles que conhecem os segredos dos Tries.  Você, um jovem aprendiz de bibliotecário, recebeu a tarefa de contar quantos livros na biblioteca começam com um determinado prefixo. A Grande Bibliotecária lhe entregou uma lista dos títulos dos livros e pediu para você implementar uma solução que conte quantos deles começam com o prefixo mágico.  Tarefa Implemente uma função count_books_with_prefix que, dada uma lista de títulos de livros e um prefixo, retorne o número de livros que começam com esse prefixo.  Função  def count_books_with_prefix(books: List[str], prefix: str) -> int:     # Implementação  Parâmetros books: Uma lista de strings books, onde cada string representa o título de um livro. O número de títulos N está no intervalo [1, 1000]. O comprimento de cada título está no intervalo [1, 100]. prefix: Uma string prefix que representa o prefixo mágico. O comprimento do prefixo está no intervalo [1, 100].  Retorno Retorne um inteiro representando o número de livros na lista que começam com o prefixo dado.  Exemplo Exemplo 1: books = [\"magic spells\", \"magical creatures\", \"magnificent potions\", \"alchemy\", \"magnetism\"] prefix = \"mag\"  output = count_books_with_prefix(books, prefix)  Saída Esperada:  3  # \"magic spells\", \"magical creatures\", \"magnificent potions\" começam com \"mag\"  ",
      "tempo": " Considere os seguintes Exemplos Na misteriosa cidade subterrânea de Arcadia, os manuscritos antigos são armazenados em uma vasta rede de cavernas. Cada manuscrito contém segredos arcanos, e os sábios de Arcadia são os únicos que conhecem todos os títulos desses manuscritos.  Recentemente, os guardiões de Arcadia descobriram que alguns manuscritos compartilham os mesmos primeiros caracteres em seus títulos. Para proteger esses manuscritos, eles precisam saber quantos deles começam com um determinado prefixo arcano.  Você, como aprendiz dos guardiões, foi encarregado de contar quantos manuscritos começam com o prefixo dado.  Tarefa Implemente uma função count_manuscripts_with_prefix que, dada uma lista de títulos de manuscritos e um prefixo, retorne o número de manuscritos que começam com esse prefixo.  Função def count_manuscripts_with_prefix(manuscripts: List[str], prefix: str) -> int:     # Implementação  Parâmetros manuscripts: Uma lista de strings manuscripts, onde cada string representa o título de um manuscrito. O número de títulos N está no intervalo [1, 2000]. O comprimento de cada título está no intervalo [1, 100]. prefix: Uma string prefix que representa o prefixo arcano. O comprimento do prefixo está no intervalo [1, 100].  Retorno Retorne um inteiro representando o número de manuscritos na lista que começam com o prefixo dado.  Exemplo Exemplo 1:  manuscripts = [\"arcane arts\", \"archery guide\", \"arctic winds\", \"alchemy\", \"architecture\"] prefix = \"arc\"  output = count_manuscripts_with_prefix(manuscripts, prefix)  Saída Esperada:  3  # \"arcane arts\", \"archery guide\", \"arctic winds\" começam com \"arc\"  class TrieNode:     def __init__(self):         self.children = {}         self.prefix_count = 0  class Trie:     def __init__(self):         self.root = TrieNode()      def insert(self, word: str) -> None:         node = self.root         for char in word:             if char not in node.children:                 node.children[char] = TrieNode()             node = node.children[char]             node.prefix_count += 1      def count_words_with_prefix(self, prefix: str) -> int:         node = self.root         for char in prefix:             if char not in node.children:                 return 0             node = node.children[char]         return node.prefix_count  def count_manuscripts_with_prefix(manuscripts: List[str], prefix: str) -> int:     trie = Trie()     for manuscript in manuscripts:         trie.insert(manuscript)     return trie.count_words_with_prefix(prefix)  No reino celestial de Astralis, os astrônomos mantêm um registro sagrado das constelações e suas histórias. Cada constelação tem um nome único, e os sábios de Astralis frequentemente precisam buscar todas as constelações que começam com um determinado prefixo, baseado nas estrelas que aparecem primeiro no céu.  Você, como aprendiz de astrônomo, foi encarregado de criar uma solução para contar quantas constelações no registro começam com um prefixo estelar específico.  Tarefa Implemente uma função count_constellations_with_prefix que, dada uma lista de nomes de constelações e um prefixo, retorne o número de constelações que começam com esse prefixo.  Função  def count_constellations_with_prefix(constellations: List[str], prefix: str) -> int:     # Implementação  Parâmetros constellations: Uma lista de strings constellations, onde cada string representa o nome de uma constelação. O número de constelações N está no intervalo [1, 1500]. O comprimento de cada nome está no intervalo [1, 100]. prefix: Uma string prefix que representa o prefixo estelar. O comprimento do prefixo está no intervalo [1, 100].   Retorno Retorne um inteiro representando o número de constelações na lista que começam com o prefixo dado.  Exemplo Exemplo 1:  constellations = [\"orion\", \"ophiuchus\", \"ursa major\", \"ursa minor\", \"orionis\"] prefix = \"or\"  output = count_constellations_with_prefix(constellations, prefix)  Saída Esperada: 2  class TrieNode:     def __init__(self):         self.children = {}         self.prefix_count = 0  class Trie:     def __init__(self):         self.root = TrieNode()      def insert(self, word: str) -> None:         node = self.root         for char in word:             if char not in node.children:                 node.children[char] = TrieNode()             node = node.children[char]             node.prefix_count += 1      def count_words_with_prefix(self, prefix: str) -> int:         node = self.root         for char in prefix:             if char not in node.children:                 return 0             node = node.children[char]         return node.prefix_count  def count_constellations_with_prefix(constellations: List[str], prefix: str) -> int:     trie = Trie()     for constellation in constellations:         trie.insert(constellation)     return trie.count_words_with_prefix(prefix)  Agora resolva o seguinte exercício:  Na antiga cidade de Eldoria, existe uma biblioteca mágica repleta de livros encantados. Esses livros contêm todo o conhecimento do mundo, e os bibliotecários de Eldoria têm a tarefa sagrada de organizar e proteger esses livros. Um dos rituais mais importantes realizados na biblioteca é a contagem dos livros que compartilham um prefixo comum no título, algo que só pode ser feito por aqueles que conhecem os segredos dos Tries.  Você, um jovem aprendiz de bibliotecário, recebeu a tarefa de contar quantos livros na biblioteca começam com um determinado prefixo. A Grande Bibliotecária lhe entregou uma lista dos títulos dos livros e pediu para você implementar uma solução que conte quantos deles começam com o prefixo mágico.  Tarefa Implemente uma função count_books_with_prefix que, dada uma lista de títulos de livros e um prefixo, retorne o número de livros que começam com esse prefixo.  Função  def count_books_with_prefix(books: List[str], prefix: str) -> int: c    # Implementação  Parâmetros books: Uma lista de strings books, onde cada string representa o título de um livro. O número de títulos N está no intervalo [1, 1000]. O comprimento de cada título está no intervalo [1, 100]. prefix: Uma string prefix que representa o prefixo mágico. O comprimento do prefixo está no intervalo [1, 100].  Retorno Retorne um inteiro representando o número de livros na lista que começam com o prefixo dado.  Exemplo Exemplo 1: books = [\"magic spells\", \"magical creatures\", \"magnificent potions\", \"alchemy\", \"magnetism\"] prefix = \"mag\"  output = count_books_with_prefix(books, prefix)  Saída Esperada:  3  # \"magic spells\", \"magical creatures\", \"magnificent potions\" começam com \"mag\"  "
    },
    "chain_of_thought": {
      "tempo": "Nas profundezas do Reino de Draconis, os guardiões dos dragões mantêm um registro secreto de todos os dragões conhecidos. Esses registros contêm informações valiosas sobre cada dragão, incluindo seu nome e suas habilidades especiais. No entanto, esses registros são vastos, e nem todos os guardiões conseguem navegar por eles com facilidade.  Um dos desafios frequentes é contar quantos nomes de dragões começam com um determinado prefixo ancestral. Você, como o novo guardião, foi designado para criar uma solução que possa realizar essa tarefa de maneira eficiente.  Tarefa Implemente uma função count_dragons_with_prefix que, dada uma lista de nomes de dragões e um prefixo ancestral, retorne o número de nomes de dragões que começam com esse prefixo.   Função  def count_dragons_with_prefix(dragons: List[str], prefix: str) -> int:     # Implementação  Parâmetros dragons: Uma lista de strings dragons, onde cada string representa o nome de um dragão. O número de nomes N está no intervalo [1, 1000]. O comprimento de cada nome está no intervalo [1, 100]. prefix: Uma string prefix que representa o prefixo ancestral. O comprimento do prefixo está no intervalo [1, 100].  Retorno Retorne um inteiro representando o número de dragões na lista que começam com o prefixo dado.   Exemplo Exemplo 1:  dragons = [\"drakon\", \"drogon\", \"dracul\", \"drogonis\", \"drake\"] prefix = \"dro\"  output = count_dragons_with_prefix(dragons, prefix)  Saída Esperada: 2   Pergunta:  Para resolver esse problema de contar quantos nomes de dragões começam com um determinado prefixo ancestral, qual seria a estrutura de dados mais eficiente em termos de tempo para esse tipo de tarefa? E como você implementaria a solução considerando que precisamos processar essa informação rapidamente? Entendimento do Problema:  O problema envolve a necessidade de identificar e contar quantas palavras em uma lista compartilham um prefixo comum. Isso sugere que precisamos de uma maneira eficiente de buscar e contar essas palavras com base em seus prefixos. Consideração de Abordagens:  Uma abordagem direta seria iterar sobre cada palavra e verificar manualmente se ela começa com o prefixo. No entanto, essa solução pode não ser a mais eficiente, especialmente para listas grandes, pois implicaria verificar o prefixo para cada palavra individualmente. Pensando em Otimização:  Podemos considerar uma abordagem onde as palavras são organizadas de tal forma que prefixos comuns sejam compartilhados, permitindo buscas rápidas por grupos de palavras que começam com o mesmo prefixo. Ao organizar as palavras dessa maneira, podemos determinar rapidamente quantas delas compartilham o prefixo desejado sem precisar verificar cada palavra individualmente. Construção e Consulta:  Primeiramente, organizaríamos todas as palavras de acordo com os caracteres iniciais, de forma que as palavras que compartilham o mesmo prefixo estejam agrupadas. Depois, ao querer contar quantas palavras começam com um determinado prefixo, simplesmente navegamos pelos caracteres do prefixo até encontrar o ponto em que essas palavras se dividem, coletando rapidamente a contagem.   Resposta Implementada:  class Node:     def __init__(self):         self.children = {}         self.prefix_count = 0  class WordOrganizer:     def __init__(self):         self.root = Node()      def add_word(self, word: str) -> None:         node = self.root         for char in word:             if char not in node.children:                 node.children[char] = Node()             node = node.children[char]             node.prefix_count += 1      def count_with_prefix(self, prefix: str) -> int:         node = self.root         for char in prefix:             if char not in node.children:                 return 0             node = node.children[char]         return node.prefix_count  def count_dragons_with_prefix(dragons: List[str], prefix: str) -> int:     organizer = WordOrganizer()     for dragon in dragons:         organizer.add_word(dragon)     return organizer.count_with_prefix(prefix)  Agora resolva o seguinte problema:  Na antiga cidade de Eldoria, existe uma biblioteca mágica repleta de livros encantados. Esses livros contêm todo o conhecimento do mundo, e os bibliotecários de Eldoria têm a tarefa sagrada de organizar e proteger esses livros. Um dos rituais mais importantes realizados na biblioteca é a contagem dos livros que compartilham um prefixo comum no título, algo que só pode ser feito por aqueles que conhecem os segredos dos Tries.  Você, um jovem aprendiz de bibliotecário, recebeu a tarefa de contar quantos livros na biblioteca começam com um determinado prefixo. A Grande Bibliotecária lhe entregou uma lista dos títulos dos livros e pediu para você implementar uma solução que conte quantos deles começam com o prefixo mágico.  Tarefa Implemente uma função count_books_with_prefix que, dada uma lista de títulos de livros e um prefixo, retorne o número de livros que começam com esse prefixo.  Função  def count_books_with_prefix(books: List[str], prefix: str) -> int:     # Implementação  Parâmetros books: Uma lista de strings books, onde cada string representa o título de um livro. O número de títulos N está no intervalo [1, 1000]. O comprimento de cada título está no intervalo [1, 100]. prefix: Uma string prefix que representa o prefixo mágico. O comprimento do prefixo está no intervalo [1, 100].  Retorno Retorne um inteiro representando o número de livros na lista que começam com o prefixo dado.  Exemplo Exemplo 1: books = [\"magic spells\", \"magical creatures\", \"magnificent potions\", \"alchemy\", \"magnetism\"] prefix = \"mag\"  output = count_books_with_prefix(books, prefix)  Saída Esperada:  3  # \"magic spells\", \"magical creatures\", \"magnificent potions\" começam com \"mag\"",
      "espaco": "Na próspera cidade de Astrovia, há uma escola de astronomia renomada onde os alunos estudam os céus e as estrelas. Uma das tarefas dos astrônomos em treinamento é catalogar todas as constelações que começam com um prefixo específico. Como parte do treinamento, você, um jovem aprendiz, foi incumbido de ajudar na contagem dessas constelações. Seu mentor entregou uma lista dos nomes das constelações e pediu para você escrever uma função que conte quantas delas começam com um prefixo específico.  Função:  def count_constellations_with_prefix(constellations: List[str], prefix: str) -> int:     # Implementação   **Parâmetros:** - `constellations`: Uma lista de strings `constellations`, onde cada string representa o nome de uma constelação. O número de nomes N está no intervalo [1, 1000]. O comprimento de cada nome está no intervalo [1, 100]. - `prefix`: Uma string `prefix` que representa o prefixo das constelações. O comprimento do prefixo está no intervalo [1, 100].  **Retorno:** - Retorne um inteiro representando o número de constelações na lista que começam com o prefixo dado.  **Exemplo:** Exemplo 1:  constellations = [\"Andromeda\", \"Antlia\", \"Apus\", \"Aquila\", \"Ara\"] prefix = \"Aq\" output = count_constellations_with_prefix(constellations, prefix)   Saída Esperada:  2  # \"Aquila\", \"Aquarius\" começam com \"Aq\"   ### Resposta com Linha de Raciocínio Otimizada para Espaço  Para resolver essa tarefa de forma eficiente em termos de espaço, precisamos evitar o uso de estruturas auxiliares de dados que consomem espaço adicional. Podemos realizar isso iterando sobre os nomes das constelações e utilizando uma simples contagem condicional.  1. Inicializamos a variável `count` com valor 0 para manter a contagem das constelações que começam com o prefixo especificado. 2. Iteramos por cada nome de constelação na lista. 3. Verificamos se o nome da constelação começa com o prefixo dado. 4. Se a condição for verdadeira, incrementamos a variável `count`. 5. Após iterar por todos os nomes, retornamos o valor da variável `count`.   Aqui está a implementação:   def count_constellations_with_prefix(constellations: List[str], prefix: str) -> int:     count = 0     for name in constellations:         if name.startswith(prefix):             count += 1     return count  # Exemplo de uso constellations = [\"Andromeda\", \"Antlia\", \"Apus\", \"Aquila\", \"Ara\"] prefix = \"Aq\" print(count_constellations_with_prefix(constellations, prefix))  # Saída Esperada: 1  Agora resolva o seguinte problema:  Na antiga cidade de Eldoria, existe uma biblioteca mágica repleta de livros encantados. Esses livros contêm todo o conhecimento do mundo, e os bibliotecários de Eldoria têm a tarefa sagrada de organizar e proteger esses livros. Um dos rituais mais importantes realizados na biblioteca é a contagem dos livros que compartilham um prefixo comum no título, algo que só pode ser feito por aqueles que conhecem os segredos dos Tries.  Você, um jovem aprendiz de bibliotecário, recebeu a tarefa de contar quantos livros na biblioteca começam com um determinado prefixo. A Grande Bibliotecária lhe entregou uma lista dos títulos dos livros e pediu para você implementar uma solução que conte quantos deles começam com o prefixo mágico.  Tarefa Implemente uma função count_books_with_prefix que, dada uma lista de títulos de livros e um prefixo, retorne o número de livros que começam com esse prefixo.  Função  def count_books_with_prefix(books: List[str], prefix: str) -> int:     # Implementação  Parâmetros books: Uma lista de strings books, onde cada string representa o título de um livro. O número de títulos N está no intervalo [1, 1000]. O comprimento de cada título está no intervalo [1, 100]. prefix: Uma string prefix que representa o prefixo mágico. O comprimento do prefixo está no intervalo [1, 100].  Retorno Retorne um inteiro representando o número de livros na lista que começam com o prefixo dado.  Exemplo Exemplo 1: books = [\"magic spells\", \"magical creatures\", \"magnificent potions\", \"alchemy\", \"magnetism\"] prefix = \"mag\"  output = count_books_with_prefix(books, prefix)  Saída Esperada:  3  # \"magic spells\", \"magical creatures\", \"magnificent potions\" começam com \"mag\" "
    },
    "solucao_otima": {
      "espaco": "O(1)",
      "tempo": "O(N*L)"
    }
  },
  {
    "id": "8",
    "dificuldade": "medio",
    "zero_shot": "Juan, um missioneiro paraguaio, tem uma missão especial: ele precisa coletar ervas medicinais em uma trilha para preparar um remédio tradicional para sua comunidade. A trilha é dividida em várias seções, e cada seção tem uma quantidade específica de ervas. Juan quer saber qual é a maior quantidade de ervas que ele pode coletar em uma sequência contínua de seções de comprimento exatamente 'k'  Tarefa: Escreva uma função maxHerbsCollected(sections: List[int], k: int) -> int que retorne a quantidade máxima de ervas que Juan pode coletar em uma sequência contínua de k seções.  Restrições: 1 ≤ len(sections) ≤ 10^5 1 ≤ sections[i] ≤ 1000 1 ≤ k ≤ len(sections)  Exemplo 1:  Input: sections = [4, 7, 2, 9, 5, 1], k = 3 Output: 16 Explanation: Juan pode coletar 16 ervas na sequência [7, 2, 9].  Exemplo 2:  Input: sections = [1, 3, 2, 6, 8], k = 2 Output: 14 Explanation: Juan pode coletar 14 ervas na sequência [6, 8].",
    "few_shot": " Considere os seguintes exemplos:  Carlos, um agricultor no interior do Paraguai, está tentando maximizar sua colheita de milho em um campo dividido em várias parcelas. Cada parcela tem uma quantidade específica de milho, e Carlos quer saber qual é a maior quantidade de milho que ele pode colher em uma sequência contínua de parcelas de comprimento exatamente 'k'. Ele precisa otimizar sua colheita para garantir que as melhores parcelas sejam escolhidas.  Problema:  Escreva uma função maxCornCollected(sections: List[int], k: int) -> int que retorne a quantidade máxima de milho que Carlos pode colher em uma sequência contínua de k parcelas.  Restrições:  1 ≤ len(sections) ≤ 10^5 1 ≤ sections[i] ≤ 1000 1 ≤ k ≤ len(sections) Exemplo 1:  Input: sections = [3, 8, 1, 10, 2, 5], k = 2 Output: 18 Explicação: Carlos pode colher 18 unidades de milho na sequência [8, 10].  def maxCornCollected(sections, k):     # Calcula a soma inicial para a primeira janela de tamanho k     max_sum = current_sum = sum(sections[:k])          # Desliza a janela pelo array     for i in range(k, len(sections)):         # Atualiza a soma atual subtraindo o primeiro elemento da janela anterior e somando o próximo elemento         current_sum += sections[i] - sections[i - k]         # Atualiza o valor máximo, se necessário         max_sum = max(max_sum, current_sum)          return max_sum  # Exemplo de uso sections = [3, 8, 1, 10, 2, 5] k = 2 print(maxCornCollected(sections, k))  # Saída: 18  Sofia é uma coletora de frutas na região de Yguazú, no Paraguai. Ela quer saber qual é a maior quantidade de frutas que pode colher em uma sequência contínua de árvores em um pomar. Cada árvore tem uma quantidade específica de frutas, e Sofia quer garantir que ela escolha as melhores árvores em uma sequência de comprimento exatamente 'k' para maximizar sua colheita.  Problema:  Escreva uma função maxFruitsCollected(sections: List[int], k: int) -> int que retorne a quantidade máxima de frutas que Sofia pode colher em uma sequência contínua de k árvores.  Restrições:  1 ≤ len(sections) ≤ 10^5 1 ≤ sections[i] ≤ 1000 1 ≤ k ≤ len(sections) Exemplo 1:  Input: sections = [5, 3, 8, 6, 7], k = 2 Output: 15 Explicação: Sofia pode colher 15 frutas na sequência [8, 7].  def maxFruitsCollected(sections, k):     # Calcula a soma inicial para a primeira janela de tamanho k     max_sum = current_sum = sum(sections[:k])          # Desliza a janela pelo array     for i in range(k, len(sections)):         # Atualiza a soma atual subtraindo o primeiro elemento da janela anterior e somando o próximo elemento         current_sum += sections[i] - sections[i - k]         # Atualiza o valor máximo, se necessário         max_sum = max(max_sum, current_sum)          return max_sum  # Exemplo de uso sections = [5, 3, 8, 6, 7] k = 2 print(maxFruitsCollected(sections, k))  # Saída: 15  Agora resolva o seguinte problema:  Juan, um missioneiro paraguaio, tem uma missão especial: ele precisa coletar ervas medicinais em uma trilha para preparar um remédio tradicional para sua comunidade. A trilha é dividida em várias seções, e cada seção tem uma quantidade específica de ervas. Juan quer saber qual é a maior quantidade de ervas que ele pode coletar em uma sequência contínua de seções de comprimento exatamente 'k'  Tarefa: Escreva uma função maxHerbsCollected(sections: List[int], k: int) -> int que retorne a quantidade máxima de ervas que Juan pode coletar em uma sequência contínua de k seções.  Restrições: 1 ≤ len(sections) ≤ 10^5 1 ≤ sections[i] ≤ 1000 1 ≤ k ≤ len(sections)  Exemplo 1:  Input: sections = [4, 7, 2, 9, 5, 1], k = 3 Output: 16 Explanation: Juan pode coletar 16 ervas na sequência [7, 2, 9].  Exemplo 2:  Input: sections = [1, 3, 2, 6, 8], k = 2 Output: 14 Explanation: Juan pode coletar 14 ervas na sequência [6, 8].",
    "chain_of_thought": "Considere o seguinte exemplo: Carlos, um jovem pescador em uma pequena vila costeira, está se preparando para o grande festival anual de pesca. Ele tem uma rede especial que só pode ser usada para pescar em uma área contínua de mar, mas com comprimento exato de 'k' metros. A vila é dividida em várias seções de 1 metro de comprimento, e Carlos sabe quantos peixes estão em cada seção do mar. Ele quer garantir que pesca a maior quantidade de peixes possível.  Tarefa:  Escreva uma função maxFishCaught(sections: List[int], k: int) -> int que retorne a quantidade máxima de peixes que Carlos pode capturar em uma sequência contínua de 'k' metros.  Restrições:  1 ≤ len(sections) ≤ 10^5 1 ≤ sections[i] ≤ 1000 1 ≤ k ≤ len(sections) Exemplo 1:  Input: sections = [10, 20, 30, 40, 50], k = 2 Output: 90 Explicação: Carlos pode capturar 90 peixes na sequência [40, 50]. Exemplo 2:  Input: sections = [5, 10, 15, 20, 25], k = 3 Output: 60 Explicação: Carlos pode capturar 60 peixes na sequência [15, 20, 25].  Para ajudar Carlos a capturar o máximo de peixes possível, precisamos analisar diferentes segmentos contínuos de comprimento exatamente 'k' dentro das seções do mar. A ideia é calcular o número de peixes que ele pode capturar em cada uma dessas possíveis áreas e, em seguida, determinar qual delas oferece o maior rendimento.  Primeira Verificação: Começamos verificando quantos peixes Carlos pode capturar nas primeiras 'k' seções. Isso nos dá um ponto de partida inicial.  Exploração das Áreas: À medida que Carlos avança sua rede um metro à frente no mar, ele deixará de pescar em uma seção anterior e passará a pescar em uma nova seção. A cada avanço, ajustamos a quantidade de peixes capturados para refletir essa mudança.  Comparação e Escolha: Em cada nova posição da rede, comparamos a quantidade de peixes capturados com o valor máximo anterior. Se a nova área rende mais peixes, atualizamos o valor máximo capturado.  Resultado Final: Após percorrer todas as possíveis posições da rede, o valor máximo encontrado será a maior quantidade de peixes que Carlos pode capturar, garantindo que ele tenha a melhor pescaria possível para o festival.   def maxFishCaught(sections, k):     max_fish = sum(sections[:k])     current_fish = max_fish          for i in range(k, len(sections)):         current_fish += sections[i] - sections[i - k]         if current_fish > max_fish:             max_fish = current_fish                  return max_fish Agora, resolva o seguinte problema: Juan, um missioneiro paraguaio, tem uma missão especial: ele precisa coletar ervas medicinais em uma trilha para preparar um remédio tradicional para sua comunidade. A trilha é dividida em várias seções, e cada seção tem uma quantidade específica de ervas. Juan quer saber qual é a maior quantidade de ervas que ele pode coletar em uma sequência contínua de seções de comprimento exatamente 'k'  Tarefa: Escreva uma função maxHerbsCollected(sections: List[int], k: int) -> int que retorne a quantidade máxima de ervas que Juan pode coletar em uma sequência contínua de k seções.  Restrições: 1 ≤ len(sections) ≤ 10^5 1 ≤ sections[i] ≤ 1000 1 ≤ k ≤ len(sections)  Exemplo 1:  Input: sections = [4, 7, 2, 9, 5, 1], k = 3 Output: 16 Explanation: Juan pode coletar 16 ervas na sequência [7, 2, 9].  Exemplo 2:  Input: sections = [1, 3, 2, 6, 8], k = 2 Output: 14 Explanation: Juan pode coletar 14 ervas na sequência [6, 8].",
    "assunto": "sliding_window",
    "solucao_otima": {
      "tempo": "O(N)",
      "espaco": "O(1)"
    }
  },
  {
    "id": "9",
    "assunto": "manipulacao_bit",
    "dificuldade": "facil",
    "tecnica_ideal": "bit_manipulation",
    "solucao_otima": {
      "tempo": "O(N)",
      "espaco": "O(1)"
    },
    "zero_shot": "Raj, um motorista indiano, está dirigindo seu caminhão por uma longa estrada com diversos postos de combustível. Cada posto é representado por um número binário, onde 1 indica que o posto está aberto e 0 indica que o posto está fechado. Raj precisa garantir que sempre haja um número ímpar de postos abertos em seu percurso para maximizar suas chances de reabastecimento.  Raj quer saber se é possível garantir essa condição em seu percurso. Se encontrar um trecho de estrada onde o número de postos abertos seja ímpar, ele pode seguir em frente com segurança.  Tarefa: Escreva uma função canEnsureFuel(stations: List[int]) -> bool que retorne True se houver pelo menos um trecho de estrada onde o número de postos abertos (bits 1) seja ímpar. Caso contrário, retorne False.  Restrições: 1 ≤ len(stations) ≤ 10^5 0 ≤ stations[i] ≤ 2^31 - 1 Exemplos: Exemplo 1:  Input: stations = [3, 5, 7] Output: True Explanation: A primeira estação (3) tem dois postos abertos (bits 1) e a segunda (5) tem dois postos abertos. A terceira (7) tem três postos abertos, que é ímpar. Portanto, Raj pode seguir em frente.  Exemplo 2:  Input: stations = [2, 4, 8] Output: False Explanation: Todos os números têm um número par de bits 1. Raj não pode garantir um número ímpar de postos abertos.",
    "few_shot": "Considere os seguintes exemplos: Sita é uma fazendeira indiana que transporta seu gado entre diferentes pastos ao longo de uma estrada rural. Cada pasto na estrada é representado por um número binário, onde 1 indica que o pasto está disponível e 0 indica que o pasto está fechado. Sita precisa garantir que sempre haja um número ímpar de pastos disponíveis em seu percurso para maximizar suas chances de encontrar pastagem suficiente para seu gado. Sita quer saber se é possível garantir essa condição em seu percurso. Se encontrar um trecho de estrada onde o número de pastos disponíveis seja ímpar, ela pode continuar seu trajeto com segurança.  Tarefa:  Escreva uma função canEnsurePasture(pastures: List[int]) -> bool que retorne True se houver pelo menos um trecho de estrada onde o número de pastos disponíveis (bits 1) seja ímpar. Caso contrário, retorne False.  Restrições:  1 ≤ len(pastures) ≤ 10^5 0 ≤ pastures[i] ≤ 2^31 - 1 Exemplos:  Input: pastures = [7, 3, 5]  Output: True  Explicação: O primeiro pasto (7) tem três pastos disponíveis (bits 1), que é ímpar, então Sita pode seguir em frente.  Input: pastures = [4, 8, 12]  Output: True  Explicação: O primeiro pasto (4) tem um pasto disponível (bit 1), que é ímpar, então Sita pode continuar seu trajeto.  from typing import List  def canEnsurePasture(pastures: List[int]) -> bool:     for pasture in pastures:         # Contar o número de bits 1 na representação binária de pasture         if bin(pasture).count('1') % 2 == 1:             return True     return False  Carlos é um mecânico brasileiro que está dirigindo seu caminhão reboque por uma estrada cheia de oficinas mecânicas. Cada oficina é representada por um número binário, onde 1 indica que a oficina está aberta e 0 indica que a oficina está fechada. Carlos precisa garantir que, em algum ponto do seu percurso, haja um número ímpar de oficinas abertas para que ele possa atender seus clientes de forma eficiente. Carlos quer saber se é possível garantir essa condição em seu percurso. Se encontrar um trecho de estrada onde o número de oficinas abertas seja ímpar, ele pode continuar sua viagem com tranquilidade.  Tarefa:  Escreva uma função canEnsureService(garages: List[int]) -> bool que retorne True se houver pelo menos um trecho de estrada onde o número de oficinas abertas (bits 1) seja ímpar. Caso contrário, retorne False.  Restrições:  1 ≤ len(garages) ≤ 10^5 0 ≤ garages[i] ≤ 2^31 - 1 Exemplos:  Input: garages = [11, 9, 14]  Output: True  Explicação: O primeiro número (11, binário 1011) tem três bits 1, que é ímpar, então Carlos pode continuar sua viagem.  Input: garages = [4, 8, 12]  Output: True  Explicação: Todos os números têm pelo menos um bit 1, que em cada caso é ímpar, então Carlos pode continuar.   from typing import List  def canEnsureService(garages: List[int]) -> bool:     for garage in garages:         # Contar o número de bits 1 na representação binária de garage         if bin(garage).count('1') % 2 == 1:             return True     return False  Raj, um motorista indiano, está dirigindo seu caminhão por uma longa estrada com diversos postos de combustível. Cada posto é representado por um número binário, onde 1 indica que o posto está aberto e 0 indica que o posto está fechado. Raj precisa garantir que sempre haja um número ímpar de postos abertos em seu percurso para maximizar suas chances de reabastecimento.  Raj quer saber se é possível garantir essa condição em seu percurso. Se encontrar um trecho de estrada onde o número de postos abertos seja ímpar, ele pode seguir em frente com segurança.  Tarefa: Escreva uma função canEnsureFuel(stations: List[int]) -> bool que retorne True se houver pelo menos um trecho de estrada onde o número de postos abertos (bits 1) seja ímpar. Caso contrário, retorne False.  Restrições: 1 ≤ len(stations) ≤ 10^5 0 ≤ stations[i] ≤ 2^31 - 1 Exemplos: Exemplo 1:  Input: stations = [3, 5, 7] Output: True Explanation: A primeira estação (3) tem dois postos abertos (bits 1) e a segunda (5) tem dois postos abertos. A terceira (7) tem três postos abertos, que é ímpar. Portanto, Raj pode seguir em frente.  Exemplo 2:  Input: stations = [2, 4, 8] Output: False Explanation: Todos os números têm um número par de bits 1. Raj não pode garantir um número ímpar de postos abertos. ",
    "chain_of_thought": "Maria, uma engenheira de redes, está analisando a conectividade entre diferentes roteadores em um grande data center. Cada roteador é representado por um número binário, onde 1 indica que o roteador está ativo e 0 indica que ele está inativo. Maria precisa garantir que, em algum ponto do data center, o número de roteadores ativos seja ímpar para assegurar a redundância da rede. Maria quer saber se é possível garantir essa condição analisando os estados dos roteadores ao longo do data center. Se encontrar um trecho onde o número de roteadores ativos seja ímpar, ela pode continuar com o plano de manutenção.  Tarefa:  Escreva uma função checkRedundancy(routers: List[int]) -> bool que retorne True se houver pelo menos um trecho onde o número de roteadores ativos (bits 1) seja ímpar. Caso contrário, retorne False.  Restrições:  1 ≤ len(routers) ≤ 10^5 0 ≤ routers[i] ≤ 2^31 - 1 Exemplos:  Input: routers = [13, 15, 6]  Output: True  Explicação: O primeiro número (13, binário 1101) tem três bits 1, que é ímpar, então Maria pode continuar com segurança.  Input: routers = [2, 4, 8]  Output: True  Explicação: Todos os números têm um único bit 1, que é ímpar, garantindo a redundância da rede.  Resolução Para resolver o problema, o primeiro passo é percorrer a lista de números que representam os roteadores. Para cada número, precisamos verificar quantos bits 1 existem na sua representação binária. Isso nos diz quantos roteadores estão ativos naquele ponto. O objetivo é encontrar pelo menos um número que tenha uma quantidade ímpar de bits 1, indicando que o número de roteadores ativos naquele ponto é ímpar. Se encontrarmos um número assim, podemos retornar imediatamente que a rede possui redundância suficiente. Caso contrário, se verificarmos todos os números e nenhum deles tiver uma quantidade ímpar de bits 1, retornamos que a condição não foi satisfeita.  from typing import List  def checkRedundancy(routers: List[int]) -> bool:     for router in routers:         if bin(router).count('1') % 2 == 1:             return True     return False Raj, um motorista indiano, está dirigindo seu caminhão por uma longa estrada com diversos postos de combustível. Cada posto é representado por um número binário, onde 1 indica que o posto está aberto e 0 indica que o posto está fechado. Raj precisa garantir que sempre haja um número ímpar de postos abertos em seu percurso para maximizar suas chances de reabastecimento.  Raj quer saber se é possível garantir essa condição em seu percurso. Se encontrar um trecho de estrada onde o número de postos abertos seja ímpar, ele pode seguir em frente com segurança.  Tarefa: Escreva uma função canEnsureFuel(stations: List[int]) -> bool que retorne True se houver pelo menos um trecho de estrada onde o número de postos abertos (bits 1) seja ímpar. Caso contrário, retorne False.  Restrições: 1 ≤ len(stations) ≤ 10^5 0 ≤ stations[i] ≤ 2^31 - 1 Exemplos: Exemplo 1:  Input: stations = [3, 5, 7] Output: True Explanation: A primeira estação (3) tem dois postos abertos (bits 1) e a segunda (5) tem dois postos abertos. A terceira (7) tem três postos abertos, que é ímpar. Portanto, Raj pode seguir em frente.  Exemplo 2:  Input: stations = [2, 4, 8] Output: False Explanation: Todos os números têm um número par de bits 1. Raj não pode garantir um número ímpar de postos abertos."
  },
  {
    "id": "10",
    "assunto": "topological_sort",
    "dificuldade": "dificil",
    "zero_shot": " Você é o engenheiro-chefe responsável pela construção de uma série de edifícios em uma nova cidade. Cada edifício precisa ser construído em uma ordem específica devido a restrições de planejamento e segurança. Algumas partes do projeto precisam ser concluídas antes que outras possam começar. Essas dependências entre os edifícios são fornecidas a você como uma lista de pares.  Por exemplo, se A deve ser construído antes de B, isso será representado como (A, B). Seu objetivo é encontrar uma ordem válida para construir todos os edifícios ou determinar que não é possível devido a um ciclo de dependências.  Tarefa:  Escreva uma função findConstructionOrder(numBuildings: int, dependencies: List[Tuple[int, int]]) -> List[int] que retorne uma lista representando uma ordem válida para a construção dos edifícios. Se não houver uma ordem válida devido a um ciclo de dependências, retorne uma lista vazia.  Restrições:  1 ≤ numBuildings ≤ 10^4 0 ≤ len(dependencies) ≤ 10^5 Os edifícios são numerados de 0 a numBuildings - 1. Exemplo:  Input:  numBuildings = 4 dependencies = [(1, 0), (2, 0), (3, 1), (3, 2)] Output: [3, 1, 2, 0]  Explicação:  Para construir o edifício 0, você deve primeiro construir tanto o edifício 1 quanto o edifício 2. Para construir os edifícios 1 e 2, você deve primeiro construir o edifício 3. Portanto, uma ordem válida de construção é [3, 1, 2, 0]. Input:   numBuildings = 2 dependencies = [(0, 1), (1, 0)] Output: []  Explicação:  As dependências formam um ciclo (0 depende de 1 e 1 depende de 0), então não é possível construir todos os edifícios. A função retorna uma lista vazia.  ",
    "few_shot": {
      "tempo": " Você é o chefe de produção em uma fábrica de brinquedos. Para montar um brinquedo complexo, várias peças precisam ser montadas em uma ordem específica devido às restrições de montagem. Algumas peças só podem ser montadas depois que outras estiverem prontas. Essas dependências entre as peças são fornecidas a você como uma lista de pares. Por exemplo, se a peça A deve ser montada antes da peça B, isso será representado como (A, B).  Tarefa:  Escreva uma função findAssemblyOrder(numParts: int, dependencies: List[Tuple[int, int]]) -> List[int] que retorne uma lista representando uma ordem válida para montar todas as peças. Se não houver uma ordem válida devido a um ciclo de dependências, retorne uma lista vazia.  Restrições:  1≤numParts≤10  0≤len(dependencies)≤10^5 As peças são numeradas de 0 a numParts - 1.  Exemplo: Input: numParts = 6 dependencies = [(5, 2), (5, 0), (4, 0), (4, 1), (2, 3), (3, 1)] Output: [5, 4, 2, 3, 1, 0]  Solução:  from typing import List, Tuple import sys sys.setrecursionlimit(1 << 25)  def findAssemblyOrder(numParts: int, dependencies: List[Tuple[int, int]]) -> List[int]:     from collections import defaultdict      graph = defaultdict(list)     for u, v in dependencies:         graph[u].append(v)      visited = [0] * numParts  # 0 = unvisited, 1 = visiting, 2 = visited     order = []     has_cycle = False      def dfs(u):         nonlocal has_cycle         if visited[u] == 1:             has_cycle = True             return         if visited[u] == 0:             visited[u] = 1             for v in graph[u]:                 dfs(v)                 if has_cycle:                     return             visited[u] = 2             order.append(u)      for i in range(numParts):         if visited[i] == 0:             dfs(i)             if has_cycle:                 return []      return order[::-1]    Você é um coordenador de eventos responsável por organizar uma conferência internacional. Existem várias sessões que precisam ser agendadas, mas algumas sessões dependem de outras por causa da disponibilidade dos palestrantes ou do conteúdo sequencial. Essas dependências são fornecidas a você como uma lista de pares. Por exemplo, se a sessão A deve ocorrer antes da sessão B, isso será representado como (A, B).  Tarefa:  Escreva uma função scheduleSessions(numSessions: int, dependencies: List[Tuple[int, int]]) -> List[int] que retorne uma lista representando uma ordem válida para agendar todas as sessões. Se não houver uma ordem válida devido a um ciclo de dependências, retorne uma lista vazia.  Restrições:  1≤numSessions≤10^4 0≤len(dependencies)≤10^5 As sessões são numeradas de 0 a numSessions - 1. Exemplo: Input: numSessions = 5 dependencies = [(0, 1), (1, 2), (2, 3), (3, 4)] Output: [0, 1, 2, 3, 4]  Solução:  from typing import List, Tuple  def scheduleSessions(numSessions: int, dependencies: List[Tuple[int, int]]) -> List[int]:     from collections import defaultdict, deque      graph = defaultdict(list)     in_degree = [0] * numSessions      for u, v in dependencies:         graph[u].append(v)         in_degree[v] += 1      queue = deque([i for i in range(numSessions) if in_degree[i] == 0])     order = []      while queue:         u = queue.popleft()         order.append(u)         for v in graph[u]:             in_degree[v] -= 1             if in_degree[v] == 0:                 queue.append(v)      if len(order) == numSessions:         return order     else:         return [] Agora resolva o seguinte problema: Você é o engenheiro-chefe responsável pela construção de uma série de edifícios em uma nova cidade. Cada edifício precisa ser construído em uma ordem específica devido a restrições de planejamento e segurança. Algumas partes do projeto precisam ser concluídas antes que outras possam começar. Essas dependências entre os edifícios são fornecidas a você como uma lista de pares.  Por exemplo, se A deve ser construído antes de B, isso será representado como (A, B). Seu objetivo é encontrar uma ordem válida para construir todos os edifícios ou determinar que não é possível devido a um ciclo de dependências.  Tarefa:  Escreva uma função findConstructionOrder(numBuildings: int, dependencies: List[Tuple[int, int]]) -> List[int] que retorne uma lista representando uma ordem válida para a construção dos edifícios. Se não houver uma ordem válida devido a um ciclo de dependências, retorne uma lista vazia.  Restrições:  1 ≤ numBuildings ≤ 10^4 0 ≤ len(dependencies) ≤ 10^5 Os edifícios são numerados de 0 a numBuildings - 1. Exemplo:  Input:  numBuildings = 4 dependencies = [(1, 0), (2, 0), (3, 1), (3, 2)] Output: [3, 1, 2, 0]  Explicação:  Para construir o edifício 0, você deve primeiro construir tanto o edifício 1 quanto o edifício 2. Para construir os edifícios 1 e 2, você deve primeiro construir o edifício 3. Portanto, uma ordem válida de construção é [3, 1, 2, 0]. Input:   numBuildings = 2 dependencies = [(0, 1), (1, 0)] Output: []  Explicação:  As dependências formam um ciclo (0 depende de 1 e 1 depende de 0), então não é possível construir todos os edifícios. A função retorna uma lista vazia. ",
      "espaco": "Você é um gerente de logística encarregado de planejar a entrega de pacotes em uma rede de cidades conectadas. Cada pacote precisa ser entregue seguindo uma ordem específica devido a restrições de rotas e prioridades. Algumas entregas devem ser concluídas antes que outras possam começar. Essas dependências entre as entregas são fornecidas a você como uma lista de pares. Por exemplo, se a entrega A deve ser feita antes da entrega B, isso será representado como (A, B).  Tarefa:  Escreva uma função planDeliveryOrder(numDeliveries: int, dependencies: List[Tuple[int, int]]) -> List[int] que retorne uma lista representando uma ordem válida para realizar todas as entregas. Se não houver uma ordem válida devido a um ciclo de dependências, retorne uma lista vazia.  Restrições:  1≤numDeliveries≤10^4 0≤len(dependencies)≤10^5 As entregas são numeradas de 0 a numDeliveries - 1.  Exemplo:  Input: numDeliveries = 3 dependencies = [(0, 1), (1, 2)] Output: [0, 1, 2]  Explicação:  A entrega 0 deve ser feita antes da entrega 1, que deve ser feita antes da entrega 2. Uma ordem válida é [0, 1, 2].  Solução:  from typing import List, Tuple  def planDeliveryOrder(numDeliveries: int, dependencies: List[Tuple[int, int]]) -> List[int]:     in_degree = [0] * numDeliveries     for _, v in dependencies:         in_degree[v] += 1      order = []     visited = [0] * numDeliveries  # 0 = unvisited, 1 = visiting, 2 = visited     has_cycle = False      def dfs(u):         nonlocal has_cycle         if visited[u] == 1:             has_cycle = True             return         if visited[u] == 0:             visited[u] = 1             for a, b in dependencies:                 if a == u:                     dfs(b)                     if has_cycle:                         return             visited[u] = 2             order.append(u)      for i in range(numDeliveries):         if in_degree[i] == 0 and visited[i] == 0:             dfs(i)             if has_cycle:                 return []      if len(order) != numDeliveries:         return []     return order[::-1]  Você é um arquiteto de software encarregado de inicializar módulos em um grande sistema. Alguns módulos dependem de outros para funcionar corretamente. Essas dependências são fornecidas a você como uma lista de pares. Por exemplo, se o módulo A deve ser inicializado antes do módulo B, isso será representado como (A, B).  Tarefa:  Escreva uma função initializeModules(numModules: int, dependencies: List[Tuple[int, int]]) -> List[int] que retorne uma lista representando uma ordem válida para inicializar todos os módulos. Se não houver uma ordem válida devido a um ciclo de dependências, retorne uma lista vazia.  Restrições: 1≤numModules≤10^4 0≤len(dependencies)≤10^5 Os módulos são numerados de 0 a numModules - 1.  Exemplo:  Input: numModules = 4 dependencies = [(2, 0), (2, 1), (3, 1)] Output: [2, 3, 0, 1]  Explicação:  O módulo 2 deve ser inicializado antes dos módulos 0 e 1. O módulo 3 deve ser inicializado antes do módulo 1. Uma ordem válida é [2, 3, 0, 1].  Solução:  from typing import List, Tuple  def initializeModules(numModules: int, dependencies: List[Tuple[int, int]]) -> List[int]:     in_degree = [0] * numModules     for _, v in dependencies:         in_degree[v] += 1      order = []     visited = [0] * numModules  # 0 = unvisited, 1 = visiting, 2 = visited     has_cycle = False      def dfs(u):         nonlocal has_cycle         if visited[u] == 1:             has_cycle = True             return         if visited[u] == 0:             visited[u] = 1             for a, b in dependencies:                 if a == u:                     dfs(b)                     if has_cycle:                         return             visited[u] = 2             order.append(u)      for i in range(numModules):         if in_degree[i] == 0 and visited[i] == 0:             dfs(i)             if has_cycle:                 return []      if len(order) != numModules:         return []     return order[::-1] Agora resolva o seguinte problema:  Você é o engenheiro-chefe responsável pela construção de uma série de edifícios em uma nova cidade. Cada edifício precisa ser construído em uma ordem específica devido a restrições de planejamento e segurança. Algumas partes do projeto precisam ser concluídas antes que outras possam começar. Essas dependências entre os edifícios são fornecidas a você como uma lista de pares.  Por exemplo, se A deve ser construído antes de B, isso será representado como (A, B). Seu objetivo é encontrar uma ordem válida para construir todos os edifícios ou determinar que não é possível devido a um ciclo de dependências.  Tarefa:  Escreva uma função findConstructionOrder(numBuildings: int, dependencies: List[Tuple[int, int]]) -> List[int] que retorne uma lista representando uma ordem válida para a construção dos edifícios. Se não houver uma ordem válida devido a um ciclo de dependências, retorne uma lista vazia.  Restrições:  1 ≤ numBuildings ≤ 10^4 0 ≤ len(dependencies) ≤ 10^5 Os edifícios são numerados de 0 a numBuildings - 1. Exemplo:  Input:  numBuildings = 4 dependencies = [(1, 0), (2, 0), (3, 1), (3, 2)] Output: [3, 1, 2, 0]  Explicação:  Para construir o edifício 0, você deve primeiro construir tanto o edifício 1 quanto o edifício 2. Para construir os edifícios 1 e 2, você deve primeiro construir o edifício 3. Portanto, uma ordem válida de construção é [3, 1, 2, 0]. Input:   numBuildings = 2 dependencies = [(0, 1), (1, 0)] Output: []  Explicação:  As dependências formam um ciclo (0 depende de 1 e 1 depende de 0), então não é possível construir todos os edifícios. A função retorna uma lista vazia."
    },
    "chain_of_thought": {
      "tempo": " Você é um coordenador de cursos em uma universidade e precisa organizar a ordem em que os alunos devem cursar as disciplinas para um determinado programa. Algumas disciplinas têm pré-requisitos que precisam ser concluídos antes de outras. Essas dependências entre as disciplinas são fornecidas a você como uma lista de pares. Por exemplo, se a disciplina A deve ser cursada antes da disciplina B, isso será representado como (A, B).  Tarefa:  Escreva uma função findCourseOrder(numCourses: int, prerequisites: List[Tuple[int, int]]) -> List[int] que retorne uma lista representando uma ordem válida para os alunos cursarem todas as disciplinas. Se não houver uma ordem válida devido a um ciclo de dependências, retorne uma lista vazia.  Restrições: 1≤numCourses≤10^4 0≤len(prerequisites)≤10^5 As disciplinas são numeradas de 0 a numCourses - 1.  Exemplo:  Input: numCourses = 4 prerequisites = [(1, 0), (2, 0), (3, 1), (3, 2)] Output: [0, 1, 2, 3]  Explicação:  As disciplinas 1 e 2 dependem da disciplina 0. A disciplina 3 depende das disciplinas 1 e 2. Uma ordem válida é [0, 1, 2, 3].  Solução:  Para otimizar a complexidade de tempo, queremos uma solução que opere em tempo O(V + E), onde: V é o número de vértices (disciplinas). E é o número de arestas (pré-requisitos). Passo a Passo do Raciocínio:  Compreensão do Problema:  Precisamos encontrar uma ordem em que as disciplinas possam ser cursadas, respeitando os pré-requisitos. Isso equivale a realizar uma ordenação topológica em um grafo direcionado acíclico (DAG). Escolha do Algoritmo:  Utilizaremos o Algoritmo de Kahn para ordenação topológica, pois ele tem complexidade de tempo O(V + E). O algoritmo de Kahn usa uma fila e o grau de entrada dos nós para determinar a ordem.  Implementação do Algoritmo: Construir o Grafo:  Representamos o grafo usando uma lista de adjacência. Para cada par (curso_dependente, curso_pré-requisito) em prerequisites, adicionamos curso_dependente à lista de adjacência de curso_pré-requisito. Calcular o Grau de Entrada:  Mantemos um array in_degree de tamanho numCourses para armazenar o número de pré-requisitos de cada curso. Incrementamos o grau de entrada de um curso toda vez que ele aparece como curso dependente. Inicializar a Fila:  Criamos uma fila com todos os cursos que têm grau de entrada zero (sem pré-requisitos). Processar os Cursos:  Enquanto a fila não estiver vazia: Removemos um curso u da fila e o adicionamos à ordem. Para cada curso v adjacente a u (cursos que dependem de u): Reduzimos o grau de entrada de v em 1. Se o grau de entrada de v se tornar zero, adicionamos v à fila.  Verificar Ciclos:  Se após o processamento o tamanho da ordem obtida for igual a numCourses, encontramos uma ordem válida. Caso contrário, existe um ciclo de dependências, e retornamos uma lista vazia.  Implementação:  from typing import List, Tuple from collections import deque, defaultdict  def findCourseOrder(numCourses: int, prerequisites: List[Tuple[int, int]]) -> List[int]:     # Construir o grafo e calcular o grau de entrada     graph = defaultdict(list)     in_degree = [0] * numCourses      for course, prereq in prerequisites:         graph[prereq].append(course)         in_degree[course] += 1      # Inicializar a fila com cursos de grau de entrada zero     queue = deque([i for i in range(numCourses) if in_degree[i] == 0])     order = []      # Processar os cursos     while queue:         u = queue.popleft()         order.append(u)         for v in graph[u]:             in_degree[v] -= 1             if in_degree[v] == 0:                 queue.append(v)      # Verificar se todos os cursos foram incluídos     if len(order) == numCourses:         return order     else:         return [] Explicação Detalhada:  Construção do Grafo e Grau de Entrada:  Inicializamos um grafo vazio usando defaultdict(list) para representar a lista de adjacência. Percorremos a lista de pré-requisitos e atualizamos: A lista de adjacência: adicionamos cada curso dependente ao curso pré-requisito. O grau de entrada: incrementamos o grau de entrada do curso dependente. Inicialização da Fila:  Identificamos todos os cursos com grau de entrada zero (sem pré-requisitos) e os adicionamos à fila. Estes cursos podem ser cursados imediatamente. Processamento dos Cursos:  Utilizamos uma fila para processar os cursos em ordem. Para cada curso u removido da fila: Adicionamos u à ordem final. Percorremos todos os cursos v que dependem de u (adjacentes a u no grafo). Reduzimos o grau de entrada de v em 1. Se o grau de entrada de v se tornar zero, adicionamos v à fila. Detecção de Ciclos:  Após processar todos os cursos, verificamos se o tamanho da lista order é igual a numCourses. Se não for, isso indica que há um ciclo no grafo, impossibilitando a conclusão de todos os cursos. Complexidade:  Tempo: A construção do grafo e o cálculo do grau de entrada levam tempo proporcional ao número de pré-requisitos O(E). O processamento dos cursos leva tempo O(V + E), pois cada curso é enfileirado e desenfileirado no máximo uma vez, e todas as arestas são percorridas. Portanto, a complexidade total é O(V + E). Espaço: Armazenamos o grafo e o grau de entrada, ocupando espaço O(V + E).  Agora resolva o seguinte problema:  Você é o engenheiro-chefe responsável pela construção de uma série de edifícios em uma nova cidade. Cada edifício precisa ser construído em uma ordem específica devido a restrições de planejamento e segurança. Algumas partes do projeto precisam ser concluídas antes que outras possam começar. Essas dependências entre os edifícios são fornecidas a você como uma lista de pares.  Por exemplo, se A deve ser construído antes de B, isso será representado como (A, B). Seu objetivo é encontrar uma ordem válida para construir todos os edifícios ou determinar que não é possível devido a um ciclo de dependências.  Tarefa:  Escreva uma função findConstructionOrder(numBuildings: int, dependencies: List[Tuple[int, int]]) -> List[int] que retorne uma lista representando uma ordem válida para a construção dos edifícios. Se não houver uma ordem válida devido a um ciclo de dependências, retorne uma lista vazia.  Restrições:  1 ≤ numBuildings ≤ 10^4 0 ≤ len(dependencies) ≤ 10^5 Os edifícios são numerados de 0 a numBuildings - 1. Exemplo:  Input:  numBuildings = 4 dependencies = [(1, 0), (2, 0), (3, 1), (3, 2)] Output: [3, 1, 2, 0]  Explicação:  Para construir o edifício 0, você deve primeiro construir tanto o edifício 1 quanto o edifício 2. Para construir os edifícios 1 e 2, você deve primeiro construir o edifício 3. Portanto, uma ordem válida de construção é [3, 1, 2, 0]. Input:   numBuildings = 2 dependencies = [(0, 1), (1, 0)] Output: []  Explicação:  As dependências formam um ciclo (0 depende de 1 e 1 depende de 0), então não é possível construir todos os edifícios. A função retorna uma lista vazia. ",
      "espaco": " Você é o diretor de pesquisa de uma empresa farmacêutica encarregado de organizar a produção de uma nova vacina. O processo de produção envolve vários estágios que devem ser executados em uma ordem específica devido a restrições químicas e regulatórias. Alguns estágios só podem começar após a conclusão de outros. Essas dependências entre os estágios são fornecidas a você como uma lista de pares. Por exemplo, se o estágio A deve ser concluído antes do estágio B, isso será representado como (A, B).  Tarefa:  Escreva uma função findProductionOrder(numStages: int, dependencies: List[Tuple[int, int]]) -> List[int] que retorne uma lista representando uma ordem válida para executar todos os estágios de produção. Se não houver uma ordem válida devido a um ciclo de dependências, retorne uma lista vazia.  Restrições:  1≤numStages≤10^4 0≤len(dependencies)≤10^5 Os estágios são numerados de 0 a numStages - 1.  Exemplo:  Input: numStages = 4 dependencies = [(0, 1), (1, 2), (2, 3)] Output: [0, 1, 2, 3]  Explicação:  O estágio 0 deve ser concluído antes do estágio 1. O estágio 1 deve ser concluído antes do estágio 2. O estágio 2 deve ser concluído antes do estágio 3. Uma ordem válida é [0, 1, 2, 3].  Solução:  Para minimizar a complexidade de espaço, queremos evitar o uso de estruturas de dados que ocupem espaço proporcional ao número de dependências (O(E)), como listas de adjacência. Em vez disso, utilizaremos apenas estruturas de tamanho proporcional ao número de estágios (O(V)), mesmo que isso aumente a complexidade de tempo. Passo a Passo do Raciocínio:  Compreensão do Problema:  Precisamos encontrar uma ordem válida para executar todos os estágios, respeitando as dependências. Isso é essencialmente uma ordenação topológica de um grafo direcionado. Objetivo de Otimização de Espaço:  Minimizar o uso de memória, utilizando apenas estruturas de tamanho O(V). Evitar armazenar listas de adjacência ou outros dados que dependam do número de arestas (E). Estratégia:  Grau de Entrada: Manter um array in_degree de tamanho O(V) para armazenar o número de dependências de cada estágio.  Processamento Dinâmico das Dependências: Em vez de armazenar as adjacências, percorrer a lista de dependências sempre que necessário para encontrar os estágios que dependem do estágio atual. Isso aumenta a complexidade de tempo, mas mantém a complexidade de espaço em O(V).  Algoritmo:  Inicialização:  Calcular o grau de entrada de cada estágio percorrendo a lista de dependências. Identificar os estágios sem dependências iniciais (grau de entrada zero). Processamento:  Usar uma fila (queue) para processar os estágios com grau de entrada zero. Para cada estágio u removido da fila: Adicionar u à ordem de execução (order). Percorrer todas as dependências para encontrar estágios v onde (u, v) é uma dependência. Reduzir o grau de entrada de v. Se o grau de entrada de v se tornar zero, adicionar v à fila. Detecção de Ciclos:  Se após o processamento a quantidade de estágios na ordem não for igual a numStages, existe um ciclo, e retornamos uma lista vazia.  Implementação:  from typing import List, Tuple from collections import deque  def findProductionOrder(numStages: int, dependencies: List[Tuple[int, int]]) -> List[int]:     # Inicializa o grau de entrada de cada estágio     in_degree = [0] * numStages     for _, v in dependencies:         in_degree[v] += 1      # Fila para estágios com grau de entrada zero     queue = deque([i for i in range(numStages) if in_degree[i] == 0])     order = []      while queue:         u = queue.popleft()         order.append(u)          # Percorre todas as dependências para encontrar estágios que dependem de u         for a, b in dependencies:             if a == u:                 in_degree[b] -= 1                 if in_degree[b] == 0:                     queue.append(b)      # Verifica se todos os estágios foram processados     if len(order) == numStages:         return order     else:         return []  Explicação Detalhada:  Inicialização do Grau de Entrada:  Percorremos a lista de dependências uma vez para calcular o grau de entrada de cada estágio. Preparação da Fila:  Todos os estágios com grau de entrada zero são adicionados à fila inicial, pois não dependem de nenhum outro estágio. Processamento dos Estágios:  Enquanto a fila não estiver vazia: Removemos um estágio u da fila e o adicionamos à ordem de execução. Percorremos todas as dependências para encontrar estágios v que dependem de u. Se encontrarmos uma dependência (u, v), reduzimos o grau de entrada de v. Se o grau de entrada de v se tornar zero, adicionamos v à fila. Detecção de Ciclos:  Após o processamento, se o tamanho da lista order for igual a numStages, encontramos uma ordem válida. Caso contrário, existe um ciclo de dependências, e retornamos uma lista vazia.  Agora resolva o seguinte problema:  Você é o engenheiro-chefe responsável pela construção de uma série de edifícios em uma nova cidade. Cada edifício precisa ser construído em uma ordem específica devido a restrições de planejamento e segurança. Algumas partes do projeto precisam ser concluídas antes que outras possam começar. Essas dependências entre os edifícios são fornecidas a você como uma lista de pares.  Por exemplo, se A deve ser construído antes de B, isso será representado como (A, B). Seu objetivo é encontrar uma ordem válida para construir todos os edifícios ou determinar que não é possível devido a um ciclo de dependências.  Tarefa:  Escreva uma função findConstructionOrder(numBuildings: int, dependencies: List[Tuple[int, int]]) -> List[int] que retorne uma lista representando uma ordem válida para a construção dos edifícios. Se não houver uma ordem válida devido a um ciclo de dependências, retorne uma lista vazia.  Restrições:  1 ≤ numBuildings ≤ 10^4 0 ≤ len(dependencies) ≤ 10^5 Os edifícios são numerados de 0 a numBuildings - 1. Exemplo:  Input:  numBuildings = 4 dependencies = [(1, 0), (2, 0), (3, 1), (3, 2)] Output: [3, 1, 2, 0]  Explicação:  Para construir o edifício 0, você deve primeiro construir tanto o edifício 1 quanto o edifício 2. Para construir os edifícios 1 e 2, você deve primeiro construir o edifício 3. Portanto, uma ordem válida de construção é [3, 1, 2, 0]. Input:   numBuildings = 2 dependencies = [(0, 1), (1, 0)] Output: []  Explicação:  As dependências formam um ciclo (0 depende de 1 e 1 depende de 0), então não é possível construir todos os edifícios. A função retorna uma lista vazia.  "
    },
    "solucao_otima": {
      "tempo": " O(V + E)",
      "espaco": "O(V)"
    }
  },
  {
    "id": "11",
    "dificuldade": "medio",
    "assunto": "binary_search",
    "solucao_otima": {
      "tempo": " O(log n)",
      "espaco": "O(1)"
    },
    "zero_shot": " Aditi, uma programadora indiana, está trabalhando em um sistema de busca eficiente para encontrar rapidamente informações em grandes volumes de dados. Problema:  Aditi precisa encontrar a primeira ocorrência de um número específico em uma lista ordenada de inteiros. Sua tarefa é ajudá-la a implementar a função findFirstOccurrence(arr: List[int], target: int) -> int.  A função deve retornar o índice da primeira ocorrência do número target na lista arr. Se o número não estiver presente, a função deve retornar -1.  Restrições:  A lista arr estará sempre ordenada em ordem crescente. 1 ≤ len(arr) ≤ 10^5 -10^9 ≤ arr[i], target ≤ 10^9 Exemplos:  Exemplo 1:  Entrada: arr = [1, 2, 4, 4, 4, 5, 6], target = 4 Saída: 2 Explicação: O número 4 aparece pela primeira vez no índice 2. Exemplo 2:  Entrada: arr = [1, 2, 3, 5, 6], target = 4 Saída: -1 Explicação: O número 4 não está presente na lista, então a função deve retornar -1. Tarefa:  Escreva a função findFirstOccurrence(arr: List[int], target: int) -> int para resolver o problema.  Resolva em Python. ",
    "few_shot": " Problema:  Ravi está trabalhando em um problema de encontrar a raiz quadrada inteira de um número x sem usar funções matemáticas nativas.  Tarefa:  Implemente a função findSquareRoot(x: int) -> int, que deve retornar a maior raiz quadrada inteira de x. Se x for um número perfeito, a função deve retornar sua raiz quadrada exata. Caso contrário, deve retornar a maior raiz quadrada inteira menor que x.  Restrições:  0 ≤ x ≤ 10^10 Exemplos:  Exemplo 1:  Entrada: x = 16 Saída: 4 Explicação: A raiz quadrada de 16 é 4. Exemplo 2:  Entrada: x = 20 Saída: 4 Explicação: A raiz quadrada inteira de 20 é 4, já que 4 * 4 = 16 e 5 * 5 = 25 (maior que 20).  def findSquareRoot(x: int) -> int:     if x < 2:         return x          left, right = 1, x // 2          while left <= right:         mid = left + (right - left) // 2         if mid * mid == x:             return mid         elif mid * mid < x:             left = mid + 1         else:             right = mid - 1          return right  Anita precisa encontrar o intervalo de índices onde um número específico target aparece em uma lista ordenada arr. Se o número não estiver presente, a função deve retornar [-1, -1]. Tarefa:  Implemente a função findRange(arr: List[int], target: int) -> List[int], que retorna uma lista com os dois índices que delimitam o intervalo de aparições de target.  Restrições:  1 ≤ len(arr) ≤ 10^5 -10^9 ≤ arr[i], target ≤ 10^9 Exemplos:  Exemplo 1:  Entrada: arr = [5, 7, 7, 8, 8, 10], target = 8 Saída: [3, 4] Explicação: O número 8 aparece pela primeira vez no índice 3 e pela última vez no índice 4. Exemplo 2:  Entrada: arr = [5, 7, 7, 8, 8, 10], target = 6 Saída: [-1, -1] Explicação: O número 6 não está presente na lista.  def findRange(arr: List[int], target: int) -> List[int]:     def binarySearch(leftSearch: bool) -> int:         left, right = 0, len(arr) - 1         result = -1         while left <= right:             mid = left + (right - left) // 2             if arr[mid] == target:                 result = mid                 if leftSearch:                     right = mid - 1                 else:                     left = mid + 1             elif arr[mid] < target:                 left = mid + 1             else:                 right = mid - 1         return result          first = binarySearch(True)     if first == -1:         return [-1, -1]          last = binarySearch(False)     return [first, last] Agora resolva o seguinte problema:    Aditi, uma programadora indiana, está trabalhando em um sistema de busca eficiente para encontrar rapidamente informações em grandes volumes de dados.  Problema:  Aditi precisa encontrar a primeira ocorrência de um número específico em uma lista ordenada de inteiros. Sua tarefa é ajudá-la a implementar a função findFirstOccurrence(arr: List[int], target: int) -> int.  A função deve retornar o índice da primeira ocorrência do número target na lista arr. Se o número não estiver presente, a função deve retornar -1.  Restrições:  A lista arr estará sempre ordenada em ordem crescente. 1 ≤ len(arr) ≤ 10^5 -10^9 ≤ arr[i], target ≤ 10^9 Exemplos:  Exemplo 1:  Entrada: arr = [1, 2, 4, 4, 4, 5, 6], target = 4 Saída: 2 Explicação: O número 4 aparece pela primeira vez no índice 2. Exemplo 2:  Entrada: arr = [1, 2, 3, 5, 6], target = 4 Saída: -1 Explicação: O número 4 não está presente na lista, então a função deve retornar -1. Tarefa:  Escreva a função findFirstOccurrence(arr: List[int], target: int) -> int para resolver o problema. ",
    "chain_of_thought": "Aman, um desenvolvedor de software, está trabalhando em uma aplicação que precisa verificar se um dado número x está presente em uma lista ordenada de inteiros arr. No entanto, Aman não quer apenas verificar a existência do número, mas também descobrir a posição onde ele aparece pela última vez. Sua tarefa é implementar a função findLastOccurrence(arr: List[int], x: int) -> int. A função deve retornar o índice da última ocorrência do número x na lista arr. Se o número não estiver presente, a função deve retornar -1.  Exemplo:  Entrada: arr = [1, 2, 2, 2, 3, 4, 5, 5], x = 2 Saída Esperada: 3 Chain of Thought:  Passo 1: Entender o Problema  Precisamos encontrar a última posição onde o número x (neste caso, 2) aparece na lista arr. Como a lista está ordenada, podemos usar a Busca Binária para realizar essa busca de forma eficiente. Passo 2: Iniciar a Busca Binária  Inicializamos dois ponteiros: left no início da lista (0) e right no final da lista (len(arr) - 1). Vamos usar a Busca Binária para procurar o número x. Cada vez que encontramos x, atualizamos um índice result com a posição atual e continuamos a busca na metade direita para garantir que encontraremos a última ocorrência. Passo 3: Calcular o Meio e Verificar  Calculamos o índice do meio com a fórmula mid = left + (right - left) // 2. Verificamos se arr[mid] é igual a x. Se for, atualizamos result para mid e movemos o ponteiro left para mid + 1, continuando a busca na metade direita. Se arr[mid] for menor que x, movemos left para mid + 1 para buscar à direita. Se arr[mid] for maior que x, movemos right para mid - 1 para buscar à esquerda. Passo 4: Finalizar e Retornar o Resultado  Continuamos o processo até que left seja maior que right. Se x foi encontrado, result conterá o índice da última ocorrência de x; caso contrário, retornaremos -1.  def findLastOccurrence(arr: List[int], x: int) -> int:     left, right = 0, len(arr) - 1     result = -1          while left <= right:         mid = left + (right - left) // 2                  if arr[mid] == x:             result = mid             left = mid + 1  # continue searching in the right half         elif arr[mid] < x:             left = mid + 1         else:             right = mid - 1          return result Agora resolva o seguinte problema: Aditi, uma programadora indiana, está trabalhando em um sistema de busca eficiente para encontrar rapidamente informações em grandes volumes de dados. Problema:  Aditi precisa encontrar a primeira ocorrência de um número específico em uma lista ordenada de inteiros. Sua tarefa é ajudá-la a implementar a função findFirstOccurrence(arr: List[int], target: int) -> int.  A função deve retornar o índice da primeira ocorrência do número target na lista arr. Se o número não estiver presente, a função deve retornar -1.  Restrições:  A lista arr estará sempre ordenada em ordem crescente. 1 ≤ len(arr) ≤ 10^5 -10^9 ≤ arr[i], target ≤ 10^9 Exemplos:  Exemplo 1:  Entrada: arr = [1, 2, 4, 4, 4, 5, 6], target = 4 Saída: 2 Explicação: O número 4 aparece pela primeira vez no índice 2. Exemplo 2:  Entrada: arr = [1, 2, 3, 5, 6], target = 4 Saída: -1 Explicação: O número 4 não está presente na lista, então a função deve retornar -1. Tarefa:  Escreva a função findFirstOccurrence(arr: List[int], target: int) -> int para resolver o problema.  Resolva em Python."
  },
  {
    "id": "12",
    "dificuldade": "dificil",
    "assunto": "backtracking",
    "solucao_otima": {
      "tempo": "O(2^n+m)",
      "espaco": "O(n+m)"
    },
    "zero_shot": "Você está visitando uma cidade famosa por seus arranha-céus. A cidade é representada por uma grade 2D onde cada célula é uma rua vazia ou contém um obstáculo. Você está localizado no canto superior esquerdo da grade e deseja chegar ao canto inferior direito. Você pode se mover apenas para a direita ou para baixo em cada passo.  Escreva uma função que encontre todos os caminhos possíveis do canto superior esquerdo para o canto inferior direito, evitando os obstáculos. O caminho não deve passar por células que contenham um obstáculo.  A função deve retornar todos os caminhos encontrados, onde cada caminho é representado por uma sequência de coordenadas visitadas.  Restrições: A grade será uma matriz de tamanho n x m com 1 ≤ n, m ≤ 10. grid[i][j] == 0 representa uma rua vazia. grid[i][j] == 1 representa um obstáculo.  Exemplo 1:  Entrada: grid = [   [0, 0, 1],   [0, 0, 0],   [1, 0, 0] ]  Saida  [[[(0, 0), (0, 1), (1, 1), (1, 2), (2, 2)], [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)], [(0, 0), (1, 0), (1, 1), (1, 2), (2, 2)], [(0, 0), (1, 0), (1, 1), (2, 1), (2, 2)]]]  Exemplo 2:  Entrada: grid = [   [0, 1],   [0, 0] ]  Saída: [   [(0, 0), (1, 0), (1, 1)] ]",
    "few_shot": {
      "tempo": " Você está caminhando por um campo de flores representado por uma grade 2D. Cada célula do campo pode ser uma área livre ou conter um obstáculo (como uma pedra). Você começa no canto superior esquerdo e precisa chegar ao canto inferior direito, movendo-se apenas para a direita ou para baixo. Escreva uma função que encontre todos os caminhos possíveis para completar essa jornada, garantindo que a solução seja otimizada para o tempo.  Restrições: O campo será uma matriz de tamanho n x m com 1 ≤ n, m ≤ 10. campo[i][j] == 0 representa uma área livre. campo[i][j] == 1 representa um obstáculo (pedra).  Exemplo 1:  Entrada: campo = [   [0, 0, 1],   [0, 1, 0],   [0, 0, 0] ]  Saída: [   [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)] ]  Implementação 1 (Otimizada para Tempo):  def find_paths_optimized_for_time_field(campo):     n = len(campo)     m = len(campo[0])     memo = {}      def backtrack(x, y):         if x == n - 1 and y == m - 1:             return [[(x, y)]]                  if (x, y) in memo:             return memo[(x, y)]          paths = []                  if y + 1 < m and campo[x][y + 1] == 0:             for path in backtrack(x, y + 1):                 paths.append([(x, y)] + path)                  if x + 1 < n and campo[x + 1][y] == 0:             for path in backtrack(x + 1, y):                 paths.append([(x, y)] + path)                  memo[(x, y)] = paths         return paths      if campo[0][0] == 0:         return backtrack(0, 0)     else:         return []  Você está atravessando um desfiladeiro perigoso, representado por uma grade 2D. Cada célula pode ser um caminho seguro ou uma rocha que bloqueia a passagem. Você começa no canto superior esquerdo e precisa chegar ao canto inferior direito, movendo-se apenas para a direita ou para baixo. Escreva uma função que encontre todos os caminhos possíveis, garantindo que a solução seja otimizada para o tempo.  Restrições: O desfiladeiro será uma matriz de tamanho n x m com 1 ≤ n, m ≤ 10. desfiladeiro[i][j] == 0 representa um caminho seguro. desfiladeiro[i][j] == 1 representa uma rocha que bloqueia a passagem.  Enunciado: Você está atravessando um desfiladeiro perigoso, representado por uma grade 2D. Cada célula pode ser um caminho seguro ou uma rocha que bloqueia a passagem. Você começa no canto superior esquerdo e precisa chegar ao canto inferior direito, movendo-se apenas para a direita ou para baixo. Escreva uma função que encontre todos os caminhos possíveis, garantindo que a solução seja otimizada para o tempo.  Restrições: O desfiladeiro será uma matriz de tamanho n x m com 1 ≤ n, m ≤ 10. desfiladeiro[i][j] == 0 representa um caminho seguro. desfiladeiro[i][j] == 1 representa uma rocha que bloqueia a passagem.  Entrada: desfiladeiro = [   [0, 0, 0],   [1, 0, 1],   [0, 0, 0] ]  Saída: [   [(0, 0), (0, 1), (0, 2), (1, 1), (2, 1), (2, 2)] ]  def find_paths_optimized_for_time_gorge(desfiladeiro):     n = len(desfiladeiro)     m = len(desfiladeiro[0])     memo = {}      def backtrack(x, y):         if x == n - 1 and y == m - 1:             return [[(x, y)]]                  if (x, y) in memo:             return memo[(x, y)]          paths = []                  if y + 1 < m and desfiladeiro[x][y + 1] == 0:             for path in backtrack(x, y + 1):                 paths.append([(x, y)] + path)                  if x + 1 < n and desfiladeiro[x + 1][y] == 0:             for path in backtrack(x + 1, y):                 paths.append([(x, y)] + path)                  memo[(x, y)] = paths         return paths      if desfiladeiro[0][0] == 0:         return backtrack(0, 0)     else:         return []  Agora resolva o seguinte problema: Você está visitando uma cidade famosa por seus arranha-céus. A cidade é representada por uma grade 2D onde cada célula é uma rua vazia ou contém um obstáculo. Você está localizado no canto superior esquerdo da grade e deseja chegar ao canto inferior direito. Você pode se mover apenas para a direita ou para baixo em cada passo.  Escreva uma função que encontre todos os caminhos possíveis do canto superior esquerdo para o canto inferior direito, evitando os obstáculos. O caminho não deve passar por células que contenham um obstáculo.  A função deve retornar todos os caminhos encontrados, onde cada caminho é representado por uma sequência de coordenadas visitadas.  Restrições: A grade será uma matriz de tamanho n x m com 1 ≤ n, m ≤ 10. grid[i][j] == 0 representa uma rua vazia. grid[i][j] == 1 representa um obstáculo.  Exemplo 1:  Entrada: grid = [   [0, 0, 1],   [0, 0, 0],   [1, 0, 0] ]  Saida  [[[(0, 0), (0, 1), (1, 1), (1, 2), (2, 2)], [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)], [(0, 0), (1, 0), (1, 1), (1, 2), (2, 2)], [(0, 0), (1, 0), (1, 1), (2, 1), (2, 2)]]]  Exemplo 2:  Entrada: grid = [   [0, 1],   [0, 0] ]  Saída: [   [(0, 0), (1, 0), (1, 1)] ]  ",
      "espaco": " Você está explorando uma floresta perigosa, representada por uma grade 2D. Cada célula pode ser uma área segura ou conter uma árvore que bloqueia o caminho. Você está no canto superior esquerdo da grade e quer chegar ao canto inferior direito. Você só pode se mover para a direita ou para baixo. Escreva uma função que encontre todos os caminhos possíveis do ponto inicial ao destino, evitando árvores.  Restrições: A grade será uma matriz de tamanho n x m com 1 ≤ n, m ≤ 10. grid[i][j] == 0 representa uma área segura. grid[i][j] == 1 representa uma árvore.  Exemplo 1: Entrada: grid = [   [0, 0, 1],   [0, 1, 0],   [0, 0, 0] ]  Saída: [   [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)] ]  Solução  def find_paths(grid):     n = len(grid)     m = len(grid[0])     result = []      def backtrack(x, y, path):         if x == n - 1 and y == m - 1:             result.append(list(path))             return                  if y + 1 < m and grid[x][y + 1] == 0:             path.append((x, y + 1))             backtrack(x, y + 1, path)             path.pop()                  if x + 1 < n and grid[x + 1][y] == 0:             path.append((x + 1, y))             backtrack(x + 1, y, path)             path.pop()      if grid[0][0] == 0:         backtrack(0, 0, [(0, 0)])          return result   Você está viajando pelo deserto e precisa encontrar um caminho seguro. O deserto é representado por uma grade 2D onde cada célula pode ser um espaço vazio ou conter uma duna de areia que bloqueia o caminho. Você começa no canto superior esquerdo e precisa chegar ao canto inferior direito, movendo-se apenas para a direita ou para baixo. Escreva uma função para encontrar todos os caminhos possíveis evitando as dunas.  Restrições: A grade será uma matriz de tamanho n x m com 1 ≤ n, m ≤ 10. grid[i][j] == 0 representa um espaço vazio. grid[i][j] == 1 representa uma duna.  Exemplo 2:  Entrada: grid = [   [0, 0, 0],   [1, 0, 1],   [0, 0, 0] ]  Saída: [   [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)] ]  Solução  def find_paths_optimized_for_memory_desert(grid):     n = len(grid)     m = len(grid[0])     result = []      def backtrack(x, y, path):         if x == n - 1 and y == m - 1:             result.append(list(path))             return                  if y + 1 < m and grid[x][y + 1] == 0:             path.append((x, y + 1))             backtrack(x, y + 1, path)             path.pop()                  if x + 1 < n and grid[x + 1][y] == 0:             path.append((x + 1, y))             backtrack(x + 1, y, path)             path.pop()      if grid[0][0] == 0:         backtrack(0, 0, [(0, 0)])          return result  Agora resolva o seguinte problema:  Você está visitando uma cidade famosa por seus arranha-céus. A cidade é representada por uma grade 2D onde cada célula é uma rua vazia ou contém um obstáculo. Você está localizado no canto superior esquerdo da grade e deseja chegar ao canto inferior direito. Você pode se mover apenas para a direita ou para baixo em cada passo.  Escreva uma função que encontre todos os caminhos possíveis do canto superior esquerdo para o canto inferior direito, evitando os obstáculos. O caminho não deve passar por células que contenham um obstáculo.  A função deve retornar todos os caminhos encontrados, onde cada caminho é representado por uma sequência de coordenadas visitadas.  Restrições: A grade será uma matriz de tamanho n x m com 1 ≤ n, m ≤ 10. grid[i][j] == 0 representa uma rua vazia. grid[i][j] == 1 representa um obstáculo.  Exemplo 1:  Entrada: grid = [   [0, 0, 1],   [0, 0, 0],   [1, 0, 0] ]  Saida  [[[(0, 0), (0, 1), (1, 1), (1, 2), (2, 2)], [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)], [(0, 0), (1, 0), (1, 1), (1, 2), (2, 2)], [(0, 0), (1, 0), (1, 1), (2, 1), (2, 2)]]]  Exemplo 2:  Entrada: grid = [   [0, 1],   [0, 0] ]  Saída: [   [(0, 0), (1, 0), (1, 1)] ] "
    },
    "chain_of_thought": {
      "tempo": " Manu está explorando um antigo templo, representado por uma grade 2D, onde cada célula pode ser um caminho livre ou uma parede. Ela começa no canto superior esquerdo e precisa chegar ao canto inferior direito, movendo-se apenas para a direita ou para baixo. O objetivo é ajudá-la a encontrar todos os caminhos possíveis para escapar do templo.  O templo é representado por uma matriz de tamanho n x m, onde 1 <= n,m <= 10. templo[i][j] == 0 indica um caminho livre. templo[i][j] == 1 indica uma parede que Manu não pode atravessar.  Exemplo de Entrada:  templo = [   [0, 0, 1],   [0, 0, 0],   [1, 0, 0] ]  Entendimento do Problema:  O problema é uma variação clássica de backtracking onde Manu deve explorar todos os caminhos possíveis para ir de uma célula inicial (0,0) até uma célula final (n-1,m-1), movendo-se apenas para a direita ou para baixo. A abordagem mais simples para encontrar esses caminhos seria usar backtracking puro, mas isso pode levar a uma recomputação desnecessária de subproblemas.  Estratégia de Otimização de Tempo com Memorização:  A ideia principal é armazenar o resultado de cada subproblema (cada posição (x,y)) em uma tabela de memorização. Assim, se precisarmos calcular os caminhos possíveis a partir de uma posição já visitada, podemos simplesmente reutilizar o resultado em vez de recalcular. Isso garante que cada posição na matriz seja processada no máximo uma vez, resultando em uma complexidade de tempo O(n * m), já que temos n * m posições na matriz.  Movimentos Permitidos:  Manu pode se mover para a direita ou para baixo, desde que o movimento não a leve para uma célula contendo uma parede. A memorização será aplicada a todas as posições acessíveis a partir de (0,0).  Processo Recursivo com Memorização:  Iniciamos a função recursiva a partir da posição (0,0). Cada vez que chegarmos a uma posição que já foi explorada, verificamos na tabela de memorização se já temos o resultado armazenado para essa posição. Caso contrário, continuamos explorando, armazenando o resultado após resolver os subproblemas.  Recursão Baseada nas Posições Futuras:  Ao alcançarmos o canto inferior direito, a função retorna o caminho encontrado. Se uma posição já foi calculada anteriormente, simplesmente retornamos o valor armazenado, o que reduz a sobrecarga computacional.  Finalização da Memorização:  Ao final da execução, teremos explorado todas as rotas possíveis com eficiência, garantindo que cada posição seja visitada apenas uma vez.  def find_paths_optimized_for_time(templo):     n = len(templo)     m = len(templo[0])     memo = {}  # Dicionário para armazenar subproblemas resolvidos      # Função recursiva com memorização     def backtrack(x, y):         # Se já chegamos ao destino, retornamos o caminho encontrado         if x == n - 1 and y == m - 1:             return [[(x, y)]]                  # Se já resolvemos este subproblema, retornamos o valor memorizado         if (x, y) in memo:             return memo[(x, y)]          paths = []                  # Tentar mover para a direita         if y + 1 < m and templo[x][y + 1] == 0:             for path in backtrack(x, y + 1):                 paths.append([(x, y)] + path)                  # Tentar mover para baixo         if x + 1 < n and templo[x + 1][y] == 0:             for path in backtrack(x + 1, y):                 paths.append([(x, y)] + path)                  # Memorizar o resultado para a célula atual         memo[(x, y)] = paths         return paths      # Iniciar a exploração se o ponto inicial for uma passagem segura     if templo[0][0] == 0:         return backtrack(0, 0)     else:         return [] Explicação dos Passos Memorização para Otimizar Tempo:  A função de backtracking utiliza um dicionário chamado memo para armazenar os caminhos já explorados a partir de cada posição (x, y). Se a posição (x, y) já foi processada, a função retorna o valor armazenado no dicionário, evitando o recalculo dos caminhos a partir dessa posição.  Evitar Recomputaçāo de Subproblemas:  O algoritmo armazena os resultados parciais em memo para garantir que cada subproblema seja resolvido apenas uma vez. Ao acessar uma célula já processada, simplesmente retornamos o valor memorizado, economizando tempo.  Exploração de Caminhos:  Para cada célula, tentamos mover para a direita ou para baixo, adicionando a posição atual ao caminho se for possível continuar. Ao atingir o canto inferior direito, retornamos o caminho completo e o armazenamos no dicionário.  Complexidade de Tempo:  Cada posição da matriz é processada no máximo uma vez, o que garante uma complexidade de O(n * m). A memorização evita que o algoritmo explore o mesmo caminho mais de uma vez, acelerando a execução.  Agora resolva o seguinte problema: Você está visitando uma cidade famosa por seus arranha-céus. A cidade é representada por uma grade 2D onde cada célula é uma rua vazia ou contém um obstáculo. Você está localizado no canto superior esquerdo da grade e deseja chegar ao canto inferior direito. Você pode se mover apenas para a direita ou para baixo em cada passo.  Escreva uma função que encontre todos os caminhos possíveis do canto superior esquerdo para o canto inferior direito, evitando os obstáculos. O caminho não deve passar por células que contenham um obstáculo.  A função deve retornar todos os caminhos encontrados, onde cada caminho é representado por uma sequência de coordenadas visitadas.  Restrições: A grade será uma matriz de tamanho n x m com 1 ≤ n, m ≤ 10. grid[i][j] == 0 representa uma rua vazia. grid[i][j] == 1 representa um obstáculo.  Exemplo 1:  Entrada: grid = [   [0, 0, 1],   [0, 0, 0],   [1, 0, 0] ]  Saida  [[[(0, 0), (0, 1), (1, 1), (1, 2), (2, 2)], [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)], [(0, 0), (1, 0), (1, 1), (1, 2), (2, 2)], [(0, 0), (1, 0), (1, 1), (2, 1), (2, 2)]]]  Exemplo 2:  Entrada: grid = [   [0, 1],   [0, 0] ]  Saída: [   [(0, 0), (1, 0), (1, 1)] ] ",
      "espaco": " Manu está presa em um labirinto subterrâneo. O labirinto é representado por uma grade 2D, onde cada célula pode ser uma passagem segura ou uma parede que bloqueia o caminho. Manu começa no canto superior esquerdo do labirinto e precisa chegar ao canto inferior direito para escapar. Ela só pode se mover para a direita ou para baixo. Escreva uma função para encontrar todos os caminhos possíveis, evitando paredes e minimizando o uso de memória.  Restrições: O labirinto será uma matriz de tamanho n x m com 1 ≤ n, m ≤ 10. labirinto[i][j] == 0 representa uma passagem segura. labirinto[i][j] == 1 representa uma parede.  Exemplo de Entrada:  labirinto = [   [0, 0, 1],   [0, 0, 0],   [1, 0, 0] ]  Resolução Detalhada Definição do Problema:  O problema é um típico caso de backtracking, onde o objetivo é encontrar todos os caminhos possíveis em uma matriz. No entanto, precisamos garantir que a implementação seja otimizada para o uso de memória, ou seja, armazenar o mínimo possível durante o processo. Backtracking puro é uma abordagem natural para este tipo de problema, pois usa a recursão e mantém apenas o caminho atual em memória, retrocedendo quando necessário. Estratégia para Otimização de Memória:  Em vez de armazenar todos os caminhos de uma vez, o algoritmo deve manter apenas o caminho atual que está sendo explorado. Conforme exploramos novos caminhos, mantemos o caminho atual em uma lista que será alterada dinamicamente conforme avançamos. A cada passo, podemos: Adicionar a próxima posição ao caminho. Retroceder removendo a última posição do caminho se chegarmos a um beco sem saída. Desta forma, apenas o caminho atual é armazenado na memória, evitando o uso excessivo de espaço. Movimentos Permitidos:  Manu pode se mover para a direita ou para baixo, desde que o destino não seja uma parede (representada por 1). A exploração deve continuar até que Manu atinja a célula final no canto inferior direito. Backtracking e Otimização:  A função backtrack será responsável por explorar todos os caminhos possíveis. Ela começará no ponto (0, 0) e tentará todas as rotas possíveis, uma de cada vez. Se a célula final for atingida, o caminho atual será adicionado aos resultados. Se um movimento não for possível, a função recursivamente desfaz o último movimento, removendo a última posição do caminho (backtracking). Esse método minimiza o uso de memória porque não mantém múltiplos estados simultâneos, apenas o caminho atual. Implementação:  Vamos implementar uma função find_paths_optimized_for_memory que utiliza a abordagem descrita. A função vai explorar o labirinto e encontrar todos os caminhos possíveis sem armazenar mais informações do que o necessário.   Agora resolva o seguinte problema:  def find_paths_optimized_for_memory(labirinto):     n = len(labirinto)     m = len(labirinto[0])     result = []      # Função de backtracking para explorar os caminhos     def backtrack(x, y, path):         # Se alcançarmos o destino, adicionamos o caminho encontrado ao resultado         if x == n - 1 and y == m - 1:             result.append(list(path))  # Guardar o caminho atual             return                  # Tentar mover para a direita         if y + 1 < m and labirinto[x][y + 1] == 0:             path.append((x, y + 1))  # Adiciona a próxima posição ao caminho             backtrack(x, y + 1, path)             path.pop()  # Retrocede (remove a última posição)                  # Tentar mover para baixo         if x + 1 < n and labirinto[x + 1][y] == 0:             path.append((x + 1, y))  # Adiciona a próxima posição ao caminho             backtrack(x + 1, y, path)             path.pop()  # Retrocede (remove a última posição)      # Iniciar a exploração a partir do ponto inicial se for uma passagem segura     if labirinto[0][0] == 0:         backtrack(0, 0, [(0, 0)])  # Começa no ponto inicial          return result       Você está visitando uma cidade famosa por seus arranha-céus. A cidade é representada por uma grade 2D onde cada célula é uma rua vazia ou contém um obstáculo. Você está localizado no canto superior esquerdo da grade e deseja chegar ao canto inferior direito. Você pode se mover apenas para a direita ou para baixo em cada passo.  Escreva uma função que encontre todos os caminhos possíveis do canto superior esquerdo para o canto inferior direito, evitando os obstáculos. O caminho não deve passar por células que contenham um obstáculo.  A função deve retornar todos os caminhos encontrados, onde cada caminho é representado por uma sequência de coordenadas visitadas.  Restrições: A grade será uma matriz de tamanho n x m com 1 ≤ n, m ≤ 10. grid[i][j] == 0 representa uma rua vazia. grid[i][j] == 1 representa um obstáculo.  Exemplo 1:  Entrada: grid = [   [0, 0, 1],   [0, 0, 0],   [1, 0, 0] ]  Saida  [[[(0, 0), (0, 1), (1, 1), (1, 2), (2, 2)], [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)], [(0, 0), (1, 0), (1, 1), (1, 2), (2, 2)], [(0, 0), (1, 0), (1, 1), (2, 1), (2, 2)]]]  Exemplo 2:  Entrada: grid = [   [0, 1],   [0, 0] ]  Saída: [   [(0, 0), (1, 0), (1, 1)] ] "
    }
  }
]
